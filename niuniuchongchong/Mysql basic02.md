# mysql

##### 三大范式：

数据库三范式（[Normalization](https://so.csdn.net/so/search?q=Normalization&spm=1001.2101.3001.7020)）是数据库设计中的一种规范标准，旨在减少数据冗余并建立结构合理的数据库，以提高数据存储和使用的性能。三范式是按照数据依赖性的程度来划分的，包括第一范式（1NF）、第二范式（2NF）和第三范式（3NF）。

第一范式：要求关系型数据库中的每个列都必须是原子的，即每列的值不能再分解成其他几列。遵循原子性。即，**表中字段的数据，不可以再拆分**

第二范式(2NF)：满足第一范式；且不存在部分依赖，即非主属性必须完全依赖于主属性。(主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分)；通俗一点讲就是一个表只能描述一件事情

第三范式(3NF)：满足第二范式；且不存在传递依赖，即非主属性不能与非主属性之间有依赖关系，非主属性必须直接依赖于主属性，不能间接依赖主属性。任何非主属性不依赖于其它非主属性（A -> B, B ->C, A -> C）即，**在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B**

通过遵循数据库三范式，可以减少数据冗余、提高数据库的整体性能、简化数据维护和更新操作，并确保数据的一致性和完整性。

##### MySQL 中的 varchar 和 char 有什么区别？

char 是一个定长字段,假如申请了`char(10)`的空间,那么无论实际存储多少内容.该字段都占用 10 个字符,而 varchar 是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.

在检索效率上来讲,char > varchar,因此在使用中,如果确定某个字段的值的长度,可以使用 char,否则应该尽量使用 varchar.例如存储用户 MD5 加密后的密码,则应该使用 char。

![1694510595295](D:/Program file/typora/img/1694510595295.png)

##### undo log和redo log的区别？

redo log日志记录的是数据页的物理变化，在服务怠机时用来同步数据，而undo log不同，它主要记录的是逻辑日志，当事务回滚时，可以逆操作恢复原来的数据；比如进行插入操作时，undo log会记录一个删除操作；redo log保证了事务的持久性，而undo log保证的是事务的原子性和一致性

##### 数据库的主从同步原理

主从同步就是主库的数据同步到从库的数据

mysql主从复制的核心就是二进制日志binlog

1、主库在事务提交时，会把数据变更记录在二进制日志文件中，

2、从库读取主库的二进制日志文件，写入到从库的中继日志，

3、从库重做中继日志中事件，将改变反映它自己的数据；

##### 主从同步的作用：

1、通过增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上向外提供读功能，

可以动态地调整从服务器的数量，从而调整整个数据库的性能。

2、提高数据安全-因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据

3、在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能

4、数据备份。一般我们都会做数据备份，可能是写定时任务，一些特殊行业可能还需要手动备份，有些行业要求备份和原数据不能在同一个地方，所以主从就能很好的解决这个问题，不仅备份及时，而且还可以多地备份，保证数据的安全

##### binlog作用？

MySQL的 binlog 是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。binlog 不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看 MySQL 执行过的所有语句。

MySQL binlog 以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。binlog 的主要目的是复制和恢复。

##### 你们项目有使用分库分表吗，具体怎么用的？

我们项目有用到分库分表，因为我们项目负责的是整个海南的云网业务，随着业务的增多，优化能提升的效果已经很小了，这次我们有用到分库分表，这样来突破io瓶颈、cpu瓶颈；我们使用的是水平分库，将一个库中的数据拆分到多个库中，解决海量数据存储和高并发的问题

**水平拆分**的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。

**垂直拆分**的意思，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。

#### 事务

##### 描述一下数据库事务：

数据库事务是指由一组数据库操作序列构成的一个逻辑工作单元，要么全部执行成功，要么全部回滚，以保证数据的完整性和一致性

##### ACID是指事务必须满足的4个特性：

原子性（Atomicity）：一个事务中的所有操作必须全部成功或全部失败，不允许出现部分成功部分失败的情况。

一致性（Consistency）：事务的执行必须使数据库从一个一致性状态变换到另一个一致性状态，即事务执行前后，数据库的完整性约束没有被破坏。
隔离性（Isolation）：多个事务之间互相独立，彼此不可见。每个事务看到的数据都是自己的独立版本，不会受到其他事务的干扰。
持久性（Durability）：一旦事务提交成功，它对数据库中的数据的改变就是永久性的，即使系统崩溃，数据也不会丢失。

##### 事务的特性是什么，可以详细说一下吗？

事务的特性有原子性、一致性、隔离性、持久性；我用一个例子来说明吧，比如A向B转账500，转账成功，A扣除500，B就要增加500，这个原子操作要么全部成功，要么全部失败；

在转账的过程中，数据都要保持一致，A扣除500，B就必须要增加500，这就体现了一致性；

在转账过程中，隔离性体现在A像B转账，不能被其他事务干扰；

在转账过程中，持久性体现在事务提交后，对数据库的改变就是持久性的



##### 并发事务带来了哪些问题，怎么解决这些问题呢？

我们在项目开发的过程中，多个事务并发是经常发生的，并发也是必然的，这就可能会导致一些问题；

第一是脏读，当一个事务正在访问数据库并对数据进行修改，而这个修改并还没有提交到数据库中，这时另一个事务也访问了这个数据库，读到了这个修改的数据，因为上一个事务还没有提交，所以这时读到的数据为脏数据；

第二是不可重复读，比如一个事务内多次读取同一数据，这个事务还没有结束，另一个事务也访问了这个数据并进行修改（提交了），这时一个事务中两次读取到的数据是不一样的，这就是不可重复读；

第三是幻读，幻读与不可重复读类似，是一个事务多次读取时，读到了一些原本不存在的记录，所以称为欢读；

对于解决这个事务并发问题，我们可以采用隔离机制，mysql支持4种隔离机制，分别是未提交读，读已提交，可重复读，串行化，默认的隔离级别是可重复读，它能解决脏读和不可重复读，但是解决不了幻读；

##### 对事务并发带来的问题，我们可做什么呢；

我们应该对事务进行隔离；mysql支持4种隔离级别，分别是：未提交读，读已提交读，可重复读，串行化，其中我们最常使用的是可重复读，这也是mysql默认的隔离级别，它可以解决脏读和不可重复读，但不能解决幻读，而串行化可以解决全部问题，但是性能比较低；



#### 索引

##### 什么是索引？为什么要使用索引：

索引是一种数据结构，是帮忙数据库快速查找数据的数据结构，并且是有序的，结构采用B+树，用于提高数据库的查询速度。它可以在一个表中快速查找指定列的值。使用索引可以提高查询速度、排序速度和分组速度，减少磁盘I/O操作次数，节省查询时间，提高数据库性能。

索引列对数据进行排序，减低了数据排序的成本，减少了cpu的消耗；

通俗来讲索引就好比书本的目录，加快[数据库](https://activity.huaweicloud.com/dbs_Promotion/index.html?utm_source=hwc-csdn&utm_medium=share-op&utm_campaign=&utm_content=&utm_term=&utm_adplace=AdPlace070851)的查询速度

##### 索引的开销主要体现在哪？  

维护索引、占用空间、回表查询

1. 占用磁盘空间。添加索引后，.ibd文件（innodb引擎）或者.myi文件（myisam引擎）会变大。
2. 降低写操作的速度。因为索引不是直接存储数据的，所以在插入、更新、删除等操作时，需要先维护索引，这会降低写操作的速度。
3. 降低查询速度。虽然索引可以加速查询，但是在某些情况下，索引会降低查询速度。例如，当查询条件不符合索引列时，MySQL需要全表扫描才能返回结果

##### 索引的缺点

- 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；
- 空间方面：索引需要占物理空间。

##### 在mysql中如何定位慢查询？

当页面加载过慢，或者在进行接口压测时间过长1、在公司里我们使用skywalking运维工具监控接口，通过这个软件我们可以快速定位是哪个接口更慢；2、在mysql中自带一个慢日志，我们在配置文件中进行开启后可以使用，在里面我们可以设置当sql执行超过多少秒时它会被记录在日志中

（当时在公司负责接口测试时，发现一个页面加载过慢，然后我通过请教组的阿哥得知我们公司是使用skywalking运维工具监控接口，在这个工具里我们可以快速定位是哪个接口更慢，并有跟踪功能，可以知道是不是sql语句执行过慢，还有一种方法是我们在mysql开启慢日志，这是mysql自带的，在里面我们可以设置当sql执行超过多少秒时，它会被记录在日志中）

##### 一个sql执行很慢，我们如何分析？

在我们实际开发过程中，我们通常通过mysql自动的执行计划explain或者DESC关键字来获取sql语句执行的相关信息，通过观察表格，

第一、我们可以通过key和key_len检查它是否有使用索引，是否命中

第二、我们可以通过type字段来判断它，属于什么查询类型，是否存在全索引扫描或全盘扫描，影响执行效率

第三、我们通过extra额外信息来判断是否出现回表情况，如果出现我们可以添加索引或者修改返回字段来进行修复；

##### 什么是B+树呢

B+树是在B树的基础上进行优化的，使其更适合外存储索引结构，B+树的非叶子结点并不存储数据，而是只存储指针，这样1、B+树磁盘读写代价更低，2、查询效率上B+更高，因为它可以通过顺序访问所有叶子节点来获取数据，而B-树只能通过查找操作来获取数据。3、因为B+树是双向指针进行连接的，所以B+树更便于扫库和区间查询

##### 红黑树你知道吗？

红黑树是由AVL树发展来的，也相当于是AVL树的进化版，AVL树是任何一个节点左子支高度与右子支高度之差的绝对值不超过1，这个规定太死了，实现起来困难，所以就出现红黑树，红黑树的节点是红色或黑色的，根是黑色的，所有的叶子都是黑色的	，每个红色节点必须有两个黑节点，红色节点不能连续，从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点；红黑树的基本操作与其他树差不多，都包括查找、增加、删除等操作，在进行这些操作的同时还要保存红黑树的规则，则就需要用到旋转操作、调色、调位操作等，旋转操作分为左旋和右旋，左旋是将某个节点旋转为其右孩子的左孩子，而右旋是节点旋转为其左孩子的右孩子

![1693907217103](D:/Program file/typora/img/1693907217103.png)



##### 了解索引的底层数据结构吗？（相等于说一下B+树）

1、数据库的InnoDB引擎采用的是B+树的数据结构来存储索引

B+树的阶数更多，路径更短；

在磁盘读写上B+代价更低，因为非叶子结点只存储指针，叶子结点才存储数据；

B+更便于扫库和区间查询，因为它是双向指针进行连接的，叶子结点是一个双向链表；

##### 有很多数据库都是采用进程的形式，你知道为什么吗

数据库采用进程的形式是因为多用户访问数据库时，需要保证数据的一致性和完整性。如果多个用户同时对同一个数据进行修改，可能会导致数据不一致的情况发生。而通过将每个用户的操作封装成一个独立的进程，可以避免多个用户之间的竞争条件和死锁等问题，从而保证数据的一致性和完整性。此外，进程还可以提高数据库的并发性和性能，因为每个进程都有自己的内存空间和资源限制，可以更好地利用计算机的硬件资源。



##### 什么是聚集索引，什么是二级索引（非聚集索引）

聚集索引是指数据和索引放在一块，B+树的索引叶子结点存储了整行数据；

二级索引是指数据和索引分开存储，B+树的叶子保存了对应的主键，可以有多个，但会产生一个问题就是二级索引并不能查找出全部数据，此时就会产生回表查询；

##### 什么是回表查询呢

通过二级索引查找对应的主键值，然后到聚集索引中查找整行的数据，这就是回表操作；

##### 覆盖索引呢？

是指查询时使用了索引，并且需要返回的列在该索引中能够全部找到；

1、我们可以使用id查询，它会直接走聚集索引，一次索引扫描，不用回表，性能更好；

2、如果按照二级索引查询数据，当前面返回的列数据并不能全部获得，则会触发回表查询，导致性能低，所以我们尽量不要使用select*，尽量在返回的列设置索引；

##### 超大分页你了解吗，如果出现怎么处理呢；

超大分页是指当数据量过大时，我们使用limit分页查询时，需要对数据进行排序，效率低，

这次我们可以使用覆盖索引跟子查询来解决，我们可以先分页查询id让它先进行覆盖索引，再使用子查询与原表id进行过滤，这样可以大大提升我们的性能



##### 索引创建的原则有哪些？

公司的项目有些表会存储大量的数据，表中的数据可能会超过10万条以上，这时我们就会创建索引，添加索引的原则有：添加索引的字段应当是使用比较频繁的字段，如作为查询条件、排序字段、分租字段这些，字段内容区分度高一些；

还有就是，在创建索引时我们应尽量使用复合索引，避免产生回表，这样会影响性能；

在某一个字段内容较长时，我们会考虑使用前缀索引，但是索引并不是越多越好，我们需要控制好索引的数量

##### 什么时候索引会失效？

我们可以通过使用mysql的自动执行计划explain来判断索引是否失效

##### 索引失效的情况：

比如，我们在使用索引时违反最左匹配原则，第二个是，模糊查询时如果%在索引前面也会导致索引失效，第三是如果我们在添加索引的字段上进行运算操作或者类型转换也都会导致索引失效；还有就是我在使用复合时，如果中间使用范围查询，也会导致后面的索引失效；

##### SQL优化的经验：

这个在日常还是很常见的，如果直说sql优化的话，我会从这几个方面进行考虑，比如建表时索引的选择，sql语句编写，主从分离、读写分离等，如果数据量很大，还可以进行分库分表；

##### 那你说一下你们具体怎么优化的

这个主要参考阿里出的那个开发手册《嵩山版》，比如，在选择字段的时候我们要根据字段内容选择合适的类型，比如是数值类型时，需要合适的选择tingint、int、bigint这些类型；

我们还可以在索引上进行优化，参考索引的创建原则，比如使用比较频繁的字段、唯一字段等作为索引，索引区分度高一点，尽量使用复合索引，避免产生回表；

在sql语言优化上，比如我们应尽量避免使用select *，指明出字段名称更好，还有就是要避免时索引失效的写法，比如在模糊查询时%不要加在在字段前面；还有就是如果是聚合查询，尽量使用union all代替union，这样效率更高；



#### 锁

##### 为什么要加锁?

当多个用户并发地存取数据时，在[数据库](https://cloud.tencent.com/solution/database?from=10680)中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。

保证多用户环境下保证数据库完整性和一致性。

##### 从锁的类别上分MySQL都有哪些锁呢？

从锁的类别上来讲，有共享锁和排他锁。

- 共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。
- 排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。

用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。

锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。

他们的加锁开销从大到小，并发能力也是从大到小。

##### 数据库的乐观锁和悲观锁是什么？怎么实现的？

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制
- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。

#### 视图

##### 数据库的视图

数据库的视图（View）是一种虚拟表格或查询结果集，它是通过一个或多个基本表（或其他视图）上的查询定义而来的。视图允许用户以一种逻辑上有组织的方式查看和操作数据库中的数据，而无需访问底层的表格结构。下面是关于数据库视图的一些重要信息：

1. **视图的创建**：视图可以使用SQL语句创建，通常是通过`CREATE VIEW`语句完成的。在创建视图时，你需要指定视图的名称、查询语句以及要访问的基本表或其他视图。

2. **视图的用途**：视图通常用于以下几个方面：

   - 简化复杂查询：通过在一个视图上定义复杂的查询，可以简化用户的查询操作，减少他们需要编写的SQL代码。
   - 数据安全性：视图可以用于限制用户对表的访问权限，只允许他们查看和操作特定的数据子集，而不是整个表。
   - 数据抽象：视图可以隐藏底层表的结构，提供更高级别的数据抽象，使用户更容易理解和操作数据。
   - 重用查询逻辑：如果有多个应用程序需要相同的查询逻辑，可以将该查询逻辑定义为一个视图，以便多个应用程序共享。

3. **更新视图**：视图通常是只读的，这意味着不能直接在视图上执行INSERT、UPDATE或DELETE等修改数据的操作。但是，一些数据库管理系统支持可更新视图，可以通过视图对基本表进行修改。

4. **性能影响**：视图的性能可能受到底层查询和索引的性能影响，因此需要谨慎设计和使用视图以确保查询效率。

5. **使用视图的示例**：以下是一个简单的示例，演示如何创建和使用一个视图：

   ```java
   sqlCopy code
   -- 创建一个视图，显示员工表中的雇员姓名和工资
   CREATE VIEW EmployeeView AS
   SELECT EmployeeName, Salary
   FROM Employee;
   
   -- 使用视图查询雇员信息
   SELECT * FROM EmployeeView;
   ```

   在这个示例中，`EmployeeView` 是一个视图，它基于 `Employee` 表的查询结果创建。然后，我们可以像查询普通表一样查询 `EmployeeView`，而不需要知道底层表结构。

数据库的视图是一个强大的工具，可以提高数据管理的灵活性和安全性。然而，在设计和使用视图时，需要考虑到性能和维护的因素，以确保其有效地满足业务需求。

