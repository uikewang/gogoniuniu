# JAVA

##### 什么是java？

java是一种面向对象的编程语言，由sun公司开发，后被orcle公司收购，java具有跨平台的特性。可以在不同的操作系统上进行运行，java语言具有封装、继承、多态的基本概念，表面java程序具有良好的重用性和可扩展性，java语言具有良好的可读性、可移植性、可扩展性，而面向对象指的是将现实世界中事物抽象为对象，通过对象之间的相互交互来完成程序设计；面向对象可以设计出低耦合的系统，但性能不及面向过程，所以嵌入式、linux开发等会使用面向过程，性能比面向过程低是因为Java 是半编译语⾔，最终的执⾏代码并不是可以直接被 CPU 执⾏的⼆进制机械码，⽽⾯向过程语⾔⼤多都是直接编译成机械码在电脑上执⾏

##### 描述一下封装：

封装是面向对象的基本概念，用于隐藏对象的细节，提供统一的接口给外部使用，这样可以避免对象的状态被破坏，使代码更加清晰和易于维护，在项目中很多时候我们都会使用到封装，比如一个员工对象，我们把的基本信息封装起来，然后在controller层进 行调用，这样可以避免了我们的代码冗余，方便阅读，同时也保护了内部的数据；

##### 那继承跟多态呢？

继承跟多态都是面向对象的基本概念，继承是子类可以继承父类的方法跟属性，进行调用，也可以通过覆盖或重写的方式来修改或者扩展父类，继承可以减少代码重复，提高代码的可维护性和可扩展性

多态是不同的对象类型可以对同一消息做出不同的响应，多态由继承和接口实现，多态：子类必须对父类方法重写，通过父类的引用去调用重写方法，必须在继承的关系下；由于java语言的继承跟多态，节省了我们编写代码时间，使代码逻辑更加清楚。

重载：在一个类里面定义多个方法，这些方法名字相同，但参数和参数个数不同，可以根据参数和参数个数来选择不同的方法，重写：在子类中定义一个与父类同名的方法，参数列表和返回值类型相同，但是可以修改或者扩展父类的方法； 

1、如果⽗类⽅法访问修饰符为 private/final/static 则⼦类就不能重写该⽅法，但是被 static修饰的⽅法能够被再次声明。

2、构造⽅法⽆法被重写

##### 那你知道什么是泛型吗？

泛型是java5中新增的特性，通过使用泛型可以在编译时检查类型安全，避免在运行时出现类型错误。泛型的本质是为了**参数化类型**（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）

##### 泛型的规定：

包装类型可用于泛型，而基本类型不可以。泛型不能使用基本类型，因为使用基本类型时会编译出错。

##### 自动装箱和拆箱呢：

也是java5中新增的特性，自动装箱是指将基本数据类型自动转换为对应的包装类型，而拆箱则是将包装类型转换为对应的基本数据类型

![1694505992156](D:/Program file/typora/img/1694505992156.png)

##### 说一下jvm：

jvm：java虚拟机，一种抽象化的[计算](https://activity.huaweicloud.com/free_test/index.html?utm_source=hwc-csdn&utm_medium=share-op&utm_campaign=&utm_content=&utm_term=&utm_adplace=AdPlace070851)机;

Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。

JVM 可以理解的代码就叫做 字节码 （即扩展名为 .class 的⽂件），它不⾯向任何特定的处理器，只⾯向虚拟机。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问题，同时⼜保留了解释型语⾔可移植的特点。所以 Java 程序运⾏时更加⾼效

##### JVM、JRE和JDK的关系是什么？

JDK是（Java Development Kit）的缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

JRE是Java Runtime Environment缩写，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。

JDK包含JRE，JRE包含JVM。

##### Java 和 C++ 的区别?

虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：

- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。
- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）
- C语言的字符或字符串也是以数组进行存储的，结尾有一个/0表示结束，而java语言中没有；
- Java 不支持 C++ 中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。

##### 说一下final关键字

final关键字可以用于成员变量、本地变量、方法以及类，final 修饰的变量必须初始化，通常称被修饰的变量为`常量`，不能对final变量再次赋值，final的方法不能被重写，但子类可以使用该方法，final的类不能被继承；

final还可以用在异常处理里面，它只能在 `try/catch` 语句中，并且附带一个语句块表示这段语句最终一定被执行（无论是否抛出异常）

##### 说一下static关键字

通常来说，用new创建类的对象时，数据存储空间才被分配，方法才供外界调用。但有时我们只想为特定域分配单一存储空间，不考虑要创建多少对象或者说根本就不创建任何对象，再就是我们想在没有创建对象的情况下也想调用方法。

##### string为什么是不可变的

String 类中使⽤ final 关键字修饰字符数组来保存字符串， private final char value[] ，所以 String 对象是不可变的。所以在使用HashMap时常用String类型的常量来做key，它的hashcode会被缓存下来，所以相比于其他对象速度更快

##### String StringBuffer 和 StringBuilder 的区别是什么

⽽ StringBuilder 与 StringBuffer 都继承⾃ AbstractStringBuilder 类，在AbstractStringBuilder 中也是使⽤字符数组保存字符串但是没有⽤ final 关键字修饰，所以这两种对象都是可变的。

在线程安全上

String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是StringBuilder 与 StringBuffer 的公共⽗类，定义了⼀些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共⽅法。StringBuffer 对⽅法加了同步锁或者对调⽤的⽅法加了同步锁，所以是线程安全的。StringBuilder 并没有对⽅法进⾏加同步锁，所以是⾮线程安全的。

在性能方面：

每次对 String 类型进⾏改变的时候，都会⽣成⼀个新的 String 对象，然后将指针指向新的 String对象，StringBuffer 每次都会对 StringBuffer 对象本身进⾏操作，⽽不是⽣成新的对象并改变对象引⽤。相同情况下使⽤ StringBuilder 相⽐使⽤ StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的⻛险。

所以操作少量的数据: 适⽤ String

单线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder

多线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer

##### 浅拷贝和深拷贝的区别：

**浅拷贝**

- 对于基本数据类型的成员变量，浅拷贝直接进行值传递，也就是将属性值复制了一份给新的成员变量
- 对于引用数据类型的成员变量，比如成员变量是数组、某个类的对象等，浅拷贝就是引用的传递，也就是将成员变量的引用（内存地址）复制了一份给新的成员变量，他们指向的是同一个事例。在一个对象修改成员变量的值时，会影响到另一个对象中成员变量的值。

**深拷贝**

- 对于基本数据类型，深拷贝复制所有基本数据类型的成员变量的值
- 对于引用数据类型的成员变量，深拷贝申请新的存储空间，并复制该引用对象所引用的对象，也就是将整个对象复制下来。所以在一个对象修改成员变量的值，不会影响到另一个对象成员变量的值。

##### 接口和抽象类的差别：

1、接口的方法默认是public，所以方法在接口中不能实现，java8开始可以实现部分方法，而抽象类可以有非抽象方法

2、接⼝中除了 static、final 变量，不能有其他变量，⽽抽象类中则不⼀定。

3、⼀个类可以实现多个接⼝，但只能实现⼀个抽象类。接⼝⾃⼰本身可以通过 extends 关键字扩展多个接⼝。

4、接⼝⽅法默认修饰符是 public，抽象⽅法可以有 public、protected 和 default 这些修饰符
（抽象⽅法就是为了被重写所以不能使⽤ private 关键字修饰！）。

5、从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接⼝是对⾏为的抽象，是⼀种⾏为的
规范。

##### == 与 equals(重要)

== : 它的作⽤是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象(基本数据类型
==比较的是值，引⽤数据类型==比较的是内存地址)。
equals() : 它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：
情况 1：类没有覆盖 equals() ⽅法。则通过 equals() ⽐᫾该类的两个对象时，等价于通过
==比较这两个对象。
情况 2：类覆盖了 equals() ⽅法。⼀般，我们都覆盖 equals() ⽅法来⽐᫾两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

##### HashCode（）介绍：

hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个 int 整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java中的任何类都包含有 hashCode() 函数。
散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利⽤到了散列码！（可以快速找到所需要的对象）

##### 为什么要有 hashCode

 当把对象加⼊ HashSet时，HashSet 会先计算对象的 hashcode 值来判断对象加⼊的位置，同时也会与该位置其他已经加⼊的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调⽤ equals() ⽅法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。这样我们就⼤⼤减少了equals 的次数，相应就⼤⼤提⾼了执⾏速度。
通过我们可以看出： hashCode() 的作⽤就是获取哈希码，也称为散列码；它实际上是返回⼀个 int整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode() 在散列表中才有⽤，在其它情况下没⽤。在散列表中 hashCode() 的作⽤是获取对象的散列码，进⽽确定该对象在散列表中的位置。
hashCode（）与 equals（）的相关规定

1. 如果两个对象相等，则 hashcode ⼀定也是相同的
2. 两个对象相等,对两个对象分别调⽤ equals ⽅法都返回 true
3. 两个对象有相同的 hashcode 值，它们也不⼀定是相等的
4. 因此，equals ⽅法被覆盖过，则 hashCode ⽅法也必须被覆盖
5. hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode()，则该 class
   的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据

##### hashCode 与 equals (重要)

⾯试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode
⽅法？”

​	如果只重写了equals方法，而不重写hashcode的方法，会造成hashcode的值不同，而equals()方法判断出来的结果为true。

​	在Java中的一些容器中，不允许有两个完全相同的对象，插入的时候，如果判断相同则会进行覆盖。这时候如果只重写了equals（）的方法，而不重写hashcode的方法，Object中hashcode是根据对象的存储地址转换而形成的一个哈希值。这时候就有可能因为没有重写hashcode方法，造成相同的对象散列到不同的位置而造成对象的不能覆盖的问题



##### 字符型常量和字符串常量的区别？

1. 形式上: 字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符；
2. 含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置，相当于对象；
3. 占内存大小：字符常量只占2个字节；字符串常量占若干个字节(至少一个字符结束标志) (注意: char 在Java中占两个字节)。

##### 什么是字符串常量池？

​	jvm为了提升性能和减少内存开销，避免字符的重复创建，其维护了一块特殊的内存空间，即字符串池，当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符串常量池中

比如String str=“aaa”，String str=new String（“aaa”），第一个语句程序运行时会在常量池中查找”aaa”字符串，若没有，会将”aaa”字符串放进常量池，再将其地址赋给str；若有，将找到的”aaa”字符串的地址赋给str。

而使用String str = new String("aaa");`，程序会在堆内存中开辟一片新空间存放新对象，同时会将”aaa”字符串放入常量池，相当于创建了两个对象，无论常量池中有没有”aaa”字符串，程序都会在堆内存中开辟一片新空间存放新对象。

##### String是基本数据类型吗？

​	不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了这些基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。

##### 什么是序列化？

​	序列化是将对象的状态保存到文件或者网络中，以便后续恢复。Java 中的序列化使用 ObjectOutputStream 进行对象序列化，使用 ObjectInputStream 进行对象反序列化。序列化可以用于数据持久化、远程通信等场景

对于不想进⾏序列化的变量，使⽤ transient 关键字修饰。（静态变量本身就不会被序列化，静态变量优先于对象存在, 随着类的加载而加载）
transient 关键字的作⽤是：阻⽌实例中那些⽤此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和⽅法。

##### volatile的使用：

在java1.2之前，java的内存模型总是从主存中进行读写，是没有问题的，但是在现在，线程可以把变量保存在本地内存，这就可能导致一个线程在内存中修改了值，但是另一个线程还使用它在寄存器中的值，造成数据不一致，这就需要我们使用volatile，声明这个变量是不稳定的，需要到内存中进行读取；

volatile和synchronized区别：

1、volatile关键字是线程同步的轻量级实现，所以volatile性能肯定⽐synchronized关键字要好。
但是volatile关键字只能⽤于变量⽽synchronized关键字可以修饰⽅法以及代码块。

2、多线程访问volatile关键字不会发生阻塞，而访问synchronnized关键字可能会发生阻塞

3、volatile关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized关键字解决的是多个线程之间访问资源的同步性

##### Java 中 IO 流分为⼏种?

按照流的流向分，可以分为输⼊流和输出流；
按照操作单元划分，可以划分为字节流和字符流；
按照流的⻆⾊划分为节点流和处理流。

InputStream/Reader: 所有的输⼊流的基类，

OutputStream/Writer: 所有输出流的基类，

##### 既然有了字节流,为什么还要有字符流?

问题本质想问：不管是⽂件读写还是⽹络发送接收，信息的最⼩存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？
回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是⾮常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就⼲脆提供了⼀个直接操作字符的接⼝，⽅便我们平时对字符进⾏流操作。如果⾳频⽂件、图⽚等媒体⽂件⽤字节流⽐字符流好，如果涉及到字符的话使⽤字符流比较好

##### 线程安全的集合有哪些？线程不安全的呢？

线程安全的：

- Hashtable：比HashMap多了个线程安全。
- ConcurrentHashMap:是一种高效但是线程安全的集合。
- Vector：比Arraylist多了个同步化机制。
- Stack：栈，也是线程安全的，继承于Vector。

线性不安全的：

- HashMap
- Arraylist
- LinkedList
- HashSet
- TreeSet
- TreeMap

##### 讲讲list

Java中的List是一个有序的集合，它允许我们按顺序存储和访问元素。List接口提供了许多方法来操作列表中的元素，包括添加、删除、获取、搜索等。List接口继承自Collection接口，因此List也具有Collection接口的所有特性。

ArrayList是List接口的一个实现类，它是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。

##### Arraylist 与 LinkedList 区别?

​			1.是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保				证线程安全

2. 底层数据结构： Arraylist 底层使⽤的是 Object 数组； LinkedList 底层使⽤的是双向链表 数据结构
3. 插⼊和删除是否受元素位置的影响： ① ArrayList 采⽤数组存储，所以插⼊和删除元素的时间复杂度受元素位置的影响。 ② LinkedList 采⽤链表存储，所以对于 add(E e) ⽅法的插⼊，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置 i 插⼊和删除元素的话（ (add(int index, E element) ） 时间复杂度近似为 o(n)) 因为需要先移动到指定位置再插⼊
4. 是否⽀持快速随机访问： LinkedList 不⽀持⾼效的随机元素访问，⽽ ArrayList ⽀持。快速随机访问就是通过元素的序号快速获取元素对象(对应于 get(int index) ⽅法)。
5. 内存空间占⽤： ArrayList的空 间浪费主要体现在在list列表的结尾会预留⼀定的容量空间，⽽LinkedList的空间花费则体现在它的每⼀个元素都需要消耗⽐ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）

##### （面试题）ArrayList和LinkedList哪个更高效？ 在什么情况下？

#####   （arraylist和linklist；什么时候arraylist比linklist查询更快）

ArrayList和LinkedList都是Java中的List接口的实现类，它们都有各自的优缺点。在大部分情况下，使用ArrayList会好一些，因为ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构。

对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。

##### ArrayList什么时候又会低效？  

​		ArrayList在添加和删除元素时，如果需要在中间或尾部进行操作，LinkedList的效率要高于ArrayList，因为LinkedList不需要移动数据，而ArrayList需要移动数据。当需要在头部进行操作时，LinkedList的效率要低于ArrayList，因为ArrayList可以通过数组下标直接访问元素，而LinkedList需要从头节点开始遍历链表。

##### ArrayList插入删除一定慢吗，什么情况不慢

讲arraylist的概念

ArrayList的插入和删除操作比LinkedList慢，因为当ArrayList需要插入删除一个元素时，会使得数组中的某些元素需要移动，从而使得插入和删除的操作变得非常耗时。ArrayList在插入和删除操作时，可能需要进行数组扩容操作，从而耗费更多的时间。插入和删除操作时，时间复杂度为O(n)，其中n表示ArrayList中元素的个数。

但是，ArrayList的查找速度很快，能够根据给定的下标直接找出对应位置的元素，时间复杂度为O(1)。

##### 为什么要用arraylist取代vector

  Vector 类的所有⽅法都是同步的。可以由两个线程安全地访问⼀个Vector对象、但是⼀个线程访问Vector的话代码要在同步操作上耗费⼤量的时间。
  Arraylist 不是同步的，所以在不需要保证线程安全时建议使⽤Arraylist。需要线程安全时使用Vector

##### 为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?

因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。

因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。

##### 相关的注入注解：

**@Autowired**:

- 解释：@Autowired 是 Spring 提供的最常用的自动装配注解之一。它可以用于自动注入依赖关系，通常与构造函数、setter 方法或字段一起使用。当 Spring 容器启动时，它会自动查找匹配类型的 Bean 并将其注入到标注了 @Autowired 的位置。

**@Value**:

- 解释：@Value 注解用于注入外部配置属性的值。你可以将属性值直接注入到字段、构造函数参数或方法参数中，并且可以使用 SpEL 表达式。

**@Resource**:

- 解释：@Resource 是	 Java EE 的注解，也可以用于 Spring 中，用于进行依赖注入。它支持按名称或类型自动装配 Bean，并且可以指定 Bean 的名称。

##### 设计模型，回答一个

是的，我了解设计模式。设计模式是一种在软件设计中经常使用的通用解决方案，它们可以帮助解决特定类型的问题，提高代码的可维护性和可重用性。

单例模式：

保证⼀个类仅有⼀个实例，并提供⼀个访问它的全局访问点，确保⼀个类只有⼀个实例，并提供该实例的全局访问

![1695870390644](D:/Program%20file/typora/img/1695870390644.png)

![1695870405420](D:/Program%20file/typora/img/1695870405420.png)

确保⼀个类只有⼀个实例，并提供该实例的全局访问点。
优点：
有些实例，全局只需要⼀个就够了，使⽤单例模式就可以避免⼀个全局使⽤的类，频繁的创建与销毁，浪费系统资源。
设计要素：
⼀个私有构造函数（确保只能单例类⾃⼰创建实例）
⼀个私有静态变量（确保只有⼀个实例）
⼀个有静态函数（给使⽤者提供调⽤⽅法） 
简单来说就是，单例类的构造⽅不让其他⼈修改和使⽤；并且单例类⾃⼰只创建⼀个实例，这个实例，其他⼈也⽆法修改和直接使⽤；然后单例类提供⼀个调⽤⽅法，想⽤这个实例，只能调⽤。这样就确保了全局只创建了⼀个实例。

使⽤场景总结：
（1）频繁实例化然后⼜销毁的对象，使⽤单例模式可以提⾼性能
（2）经常使⽤的对象，但实例化时ᘙᩇ时间或者资源多，如数据库连接࿰，使⽤单例模式，
可以提⾼性能，降低资源利用率
（3）使⽤线程池之类的控制资源时，使⽤单例模式，可以⽅便资源之间的通信

设计模型有很多种，如创建型模式：
1、⼯⼚⽅法(factory method)模式：
定义⼀个创建对象的接⼝，但由⼦类决定需要实例化ߺ一个类。⼯厂方法使得⼦类实例化的过程推迟
2、抽象⼯⼚(abstract factory)模式：
提供⼀个接⼝，可以创建⼀系列相关或相互依赖的对象，⽽⽆需指定他们具体的类
3、原型(prototype)模式：
⽤原型实例指定创建对象的类型，并且通过拷⻉这个原型来创建新的对象
4、单例(singleton)模式：
保证⼀个类只有⼀个实例，并提供⼀个访问它的全局访问点
5、构建器(builder)模式：
将⼀个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示

#### 异常

##### 你了解java中的异常吗？

异常是java中的一种错误机制，用于处理程序中发生的异常情况，异常分为受检异常和非受检异常，受检异常需要在方法签名中进行声明，用于处理或抛出异常，非受检异常不需要在方法签名中进行声明，可以在任何地方抛出

##### Error 和 Exception 区别是什么？

Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类 `Exception`（异常）和 `Error`（错误）。

`Exception` 和 `Error` 二者都是 Java 异常处理的重要子类，各自都包含大量子类。

- **Exception** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。`Exception` 又可以分为受检异常和非受检异常) 。
- **Error** ：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。

##### throws 关键字和 throw 关键字在使用上的几点区别如下：

- throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。
- throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。

#### 集合

##### 你了解集合吗？

集合是java中的一种数据结构，用来存储一组对象，分为list、set、map三种类型，list用来存储有序元素，可以重复；set用来存储无序元素，不可以重复；map用来存储键值对，键不可以重复；

其中List 提供了一组操作序列的方法，可以通过索引访问元素，可以实现栈、队列、链表等数据结构。Set 提供了一组操作集合的方法，可以实现交、并、差等集合运算。Map 提供了一组操作键值对的方法，可以实现字典、哈希表等数据结构。

#### 线程

##### 你说一下线程：

线程是程序执行的最小单位，是进程中的一个独立执行流，可以同时执行多线程，实现多任务处理；

而多线程是指一个进程可以包括一个或者多个线程，每个线程可以独立执行不同的任务，实现多任务处理，在java中多线程用Thread类和Runable接口实现，多线程可以提高程序并行和效率，但同时也会带来线程安全问题； 

**Java线程具有五中基本状态**

**1）新建状态（New）**：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();

**2）就绪状态（Runnable）**：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；

**3）运行状态（Running）**：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；

**4）阻塞状态（Blocked）**：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：

1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；

2.同步阻塞 — 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；

3.其他阻塞 — 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时. join()等待线程终止或者超时. 或者I/O处理完毕时，线程重新转入就绪状态。

**5）死亡状态（Dead）**：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

##### 怎么开启一个线程

在Java中，有多种方法可以开启一个线程。以下是其中三种方法：

1. 继承Thread类

- 定义一个继承自Java.lang.Thread类的类
- 覆盖该类的run方法
- 在run方法中编写需要执行的操作：run方法中的代码，线程执行体
- 在main方法（线程）中，创建一个该类的实例，即创建线程对象
- 调用线程对象的start()方法来启动该线程

1. 实现Runnable接口

- 定义一个实现Runnable接口的类
- 在该类中实现run()方法
- 在main方法（线程）中，创建一个实现Runnable接口的对象，并将其作为参数传递给Thread类的构造函数
- 调用Thread对象的start()方法来启动该线程

1. 匿名内部类

- 在main方法（线程）中，创建一个匿名内部类的对象
- 将该匿名内部类对象作为参数传递给Thread类的构造函数
- 调用Thread对象的start()方法来启动该线程

##### 2.3.4. 为什么要使⽤多线程呢?

先从总体上来说：
从计算机底层来说： 线程可以⽐作是轻量级的进程，是程序执⾏的最⼩单位,线程间的切换和调度的成本远远⼩于进程。另外，多核 CPU 时代意味着多个线程可以同时运⾏，这减少了线程上下⽂切换的开销。
从当代互联⽹发展趋势来说： 现在的系统动不动就要求百万级甚⾄千万级的并发量，⽽多线程并发编程正是开发⾼并发系统的基础，利⽤好多线程机制可以⼤⼤提⾼系统整体的并发能⼒以及性能。
再深⼊到计算机底层来探讨：
单核时代： 在单核时代多线程主要是为了提⾼ CPU 和 IO 设备的综合利⽤率。举个例⼦：当只有⼀个线程的时候会导致 CPU 计算时，IO 设备空闲；进⾏ IO 操作时，CPU 空闲。我们可以简单地说这两者的利⽤率⽬前都是 50%左右。但是当有两个线程的时候就不⼀样了，当⼀个线程执⾏ CPU 计算时，另外⼀个线程可以进⾏ IO 操作，这样两个的利⽤率就可以在理想情况下达到100%了。
多核时代: 多核时代多线程主要是为了提⾼ CPU 利⽤率。举个例⼦：假如我们要计算⼀个复杂的任务，我们只⽤⼀个线程的话，CPU 只会⼀个 CPU 核⼼被利⽤到，⽽创建多个线程就可以让多个 CPU 核⼼被利⽤到，这样就提⾼了 CPU 的利⽤率

##### 2.3.5. 使⽤多线程可能带来什么问题?

并发编程的⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度，但是并发编程并不总是能提⾼程序运⾏速度的，⽽且并发编程可能会遇到很多问题，⽐如：内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题。

带来线程不安全是由于在多线程环境下，程序可能会发生数据并发等问题，导致程序不能正确执行或产生错误结果；因此线程不安全的程序可以同步来进行处理，同步是指在多线程环境下，通过对共享资源的访问进行协调和处理，以确保多个线程之间的操作能够正常执行，保护了线程安全和数据一致性；

实现线程同步可以使用synchronized关键字、lock接口、volatile关键字、原子类；

##### 那什么是线程池呢？

线程池是一种管理和复用线程的机制，可以提高多线程程序的性能和复用性；它可以预先创建一些线程，并且维护一个任务队列，当有新的任务需要执行时，就会将任务添加到任务队列中，然后由空闲的线程来执行任务。使用线程池可以避免重复创建和销毁线程的开销，提⾼响应速度，提⾼线程的可管理性，从而提高系统的性能

线程池的工作原理如下：

初始化线程池，创建一定数量的线程，并将它们置于等待状态。
当有新的任务到来时，线程池会将任务添加到任务队列中。
空闲线程会从任务队列中取出任务并执行，直到任务队列为空。
如果任务队列为空，空闲线程会继续等待新的任务到来。
如果任务队列已满，并且所有的线程都在执行任务，线程池会根据配置的策略来处理任务，如阻塞、抛弃等。

线程池中的核心线程数是线程池中最小的线程数，即使线程池中没有任务，核心线程也会一直存在，直到线程池被关闭。最大线程数是线程池中最大的线程数，当任务数量超过核心线程数时，线程池会创建新的线程来处理任务，直到线程数量达到最大线程数为止。

1、execute() ⽅法⽤于提交不需要返回值的任务，所以⽆法判断任务是否被线程池执⾏成功与
否；

2、submit() ⽅法⽤于提交需要返回值的任务。线程池会返回⼀个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执⾏成功

死锁：

多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止；

##### 线程池满了之后的处理：

当线程池满了之后，新的任务无法立即获得执行线程，需要考虑如何处理这种情况以确保系统的稳定性和性能。一般有以下几种处理方式：

1. **拒绝策略（Rejection Policy）**：线程池通常提供了一种拒绝策略，用于确定在线程池已满的情况下如何处理新的任务。常见的拒绝策略包括：
   - **AbortPolicy（默认策略）**：新任务会抛出RejectedExecutionException异常。
   - **CallerRunsPolicy**：线程池会尝试使用当前线程执行新任务。这可能会导致调用线程被阻塞。
   - **DiscardPolicy**：新任务会被丢弃，不会得到执行。
   - **DiscardOldestPolicy**：丢弃队列中最旧的任务，然后执行新任务。
2. **调整线程池参数**：你可以考虑增加线程池的核心线程数或最大线程数来容纳更多的任务。这会增加系统的并发能力，但需要谨慎，以避免创建过多线程导致资源消耗过大。
3. **使用有界队列**：线程池通常有一个工作队列，用于存储等待执行的任务。你可以使用有界队列，限制队列的最大容量。当队列满时，新的任务会触发拒绝策略。有界队列可以帮助控制线程池的资源消耗，避免无限制的任务堆积。
4. **优雅降级**：如果应用程序可以容忍一些功能的降级，可以考虑实现一种策略，当线程池满时，将一部分任务标记为低优先级或临时延迟执行，以确保高优先级任务继续得到执行。
5. **任务队列的持久化**：如果任务不是必须实时执行的，可以将任务队列的内容持久化到外部存储，并在有空闲线程时重新加载和执行。这适用于一些后台处理任务的场景。
6. **监控和报警**：在生产环境中，应该实施监控和报警机制，以便及时检测到线程池满了的情况，并采取适当的措施，如扩展线程池或发出警报，以便运维人员能够介入。

选择适当的处理方式取决于应用程序的需求和性能要求。在设计线程池时，需要根据负载、任务类型和系统资源等因素来调整线程池的参数和拒绝策略，以确保系统能够在高负载下保持稳定和可伸缩。

##### 死锁必须具备以下四个条件

- 互斥条件：该资源任意一个时刻只由一个线程占用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
- 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

##### 说一说sleep（）和wait（）的相同点和区别：

两者最大的区别在于sleep方法不会释放锁，而wait方法会释放锁

两者都可以用来线程暂停，但sleep可以自动唤醒，但wait（）不会自动唤醒，需要等待别的线程调用notify（）或者notifyall（）才能唤醒；sleep通常用来线程暂停执行，wait通常用来线程间交互和通信、

##### 2.3.10. 为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？

这是另⼀个⾮常经典的 java 多线程⾯试问题，⽽且在⾯试中会经常被问到。很简单，但是很多⼈都会
答不上来！
new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。总结： 调⽤ start ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ run ⽅法只是 thread 的⼀个普通⽅法调⽤，还是在主线程⾥执⾏。

程序计数器：

1. 字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执⾏、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置，从⽽当线程被切换回来的时候能够知道该线程上次运⾏到哪⼉了。