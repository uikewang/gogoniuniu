# 计算机网络：

##### Cookie的作⽤是什么?和Session有什么区别？

  Cookie 和 Session都是⽤来跟踪浏览器⽤户身份的会话⽅式，但是两者的应⽤场景不太⼀样。

  Cookie ⼀般⽤来保存⽤户信息 ⽐如①我们在 Cookie 中保存已经登录过得⽤户信息，下次访问⽹站的
  时候⻚⾯可以⾃动帮你登录的⼀些基本信息给填了；②⼀般的⽹站都会有保持登录也就是说下次你再访
  问⽹站的时候就不需要重新登录了，这是因为⽤户登录的时候我们可以存放了⼀个 Token 在 Cookie
  中，下次登录的时候只需要根据 Token 值来查找⽤户即可(为了安全考虑，重新登录⼀般要将 Token
  重写)；③登录⼀次⽹站后访问⽹站其他⻚⾯不需要重新登录。Session 的主要作⽤就是通过服务端记
  录⽤户的状态。 典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作
  的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定的 Session 之后就可以标识这个⽤户
  并且跟踪这个⽤户了。
  Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。
  Cookie 存储在客户端中，⽽Session存储在服务器上，相对来说 Session 安全性更⾼。如果要在
  Cookie 中存储⼀些敏感信息，不要直接写⼊ Cookie 中，最好能将 Cookie 信息加密然后使⽤到的时
  候再去服务器端解密。

##### URI和URL的区别是什么?

  URI的作⽤像身份证号⼀样，URL的作⽤更像家庭住址⼀样。URL是⼀种具体的URI，它不仅唯⼀标识资
  源，⽽且还提供了定位该资源的信息。

##### 说一下三次握手:

三次握手是TCP协议用于建立可靠连接的过程，其步骤如下：

第一次握手（SYN）：客户端向服务器发送SYN包，标志位SYN置为1，请求建立连接。该包中包含一个随机生成的初始序列号ISN（Initial Sequence Number）。

第二次握手（SYN+ACK）：服务器收到SYN包后，由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，向客户端发送SYN+ACK包，表示同意建立连接。该包中也包含一个随机生成的序列号ISN，同时将确认序列号ACK设置为客户端的ISN+1。

第三次握手（ACK）：客户端收到服务器的SYN+ACK包后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，向服务器发送ACK包，表示客户端也同意建立连接。该包的序列号设置为服务器的ISN+1，确认序列号设置为服务器的ISN+1

在三次握手完成后，TCP连接建立成功，双方可以开始进行数据传输。这个过程可以确保连接的可靠性和完整性，防止数据包的丢失或重复传输

##### 背诵：

TCP/IP 协议是传输层的一个面向连接的安全可靠的一个传输协议，三次握手的机制是为了保证能建立一个安全可靠的连接，那么第一次握手是由客户端发起，客户端会向服务端发送一个报文，在报文里面：SYN标志位置为1，表示发起新的连接。当服务端收到这个报文之后就知道客户端要和我建立一个新的连接，于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack标志位置为1，表示确认客户端发起的第一次连接请求。以上两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。所以，还需要进行第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个ack标志位置1的确认消息。通过以上三次连接，不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。那么，这个连接就被安全的建立了

##### 四次挥手呢：

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

四次挥手原理：

第1次挥手：客户端打算断开连接，客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；

第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；

第3次挥手：服务器也打算断开连接，服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态；

第4次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手。

##### 背诵：

四次挥手：由客户端首先发起的，第一次挥手客户端会发送一个报文，在报文里面FIN标志位置1，当服务端收到这个报文就知道了客户端想要和我断开连接，但是此时服务端不一定能做好准备，因为当客户端发起断开连接的请求后，对于服务端而言还极有可能有未发送完的消息，还需继续发送，所以此时对于服务端而言只能进行一个消息确认（第二次挥手），即告诉客户端我知道你要和我断开连接，但是我这边还可能没有做好准备，你需要等我一下，等会儿我会告诉你（第三次挥手），于是，发完这个消息确认包过后，可能稍过片刻，服务端会继续发送一个断开连接的报文（第三次挥手），FIN位置1的报文，表示服务端已经做好断开连接的准备，当这个报文发给客户端的时候，客户端同样要给服务端发送一个消息确认的报文（第四次挥手），经过这四次的相互沟通和连接，我就知道了不管是客户端还是服务端都已经做好了断开连接的准备，于是连接断开了，这是我对四次挥手的理解



OSI与TCP/IP各层的结构与功能,都有哪些协议?

学习计算机⽹络时我们⼀般采⽤折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采⽤⼀种只有五层
协议的体系结构，这样既简洁⼜能将概念阐述清楚。

![1694068283877](D:/Program file/typora/img/1694068283877.png)

##### 计算机网络的层次结构：

应用层、运输层、网络层、数据链路层、物理层
应用层的主要任务是h通过应用进程间的交互来完成特定的网络应用，应用层协议定义的是应用进程间的的通信和交互的规则；
运输层的主要任务是负责向两台主机进程之间的通信提供通用的数据传输服务；
网络层：在计算机网络中进行通信的两个计算机可能会经过很多个数据链路，也可能会经过很多个子网，网络层的任务就是选择合适的网间路由和交换结点；
数据链路层简称为链路层，两台主机间的数据传输，都是在一段一段的链路上传输的，这就需要专门的链路层协议；
物理层的作用是实现相邻节点之间的比特流透明传输，尽可能的屏蔽掉具体传输媒介和物理设备的差异；

##### TCP,UDP 协议的区别：

UDP 在传送数据之前不需要先建⽴连接，远地主机在收到 UDP 报⽂后，不需要给出任何确认。虽然
UDP 不提供可靠交付，但在某些情况下 UDP 确是⼀种最有效的⼯作⽅式（⼀般⽤于即时通信），⽐
如： QQ 语⾳、 QQ 视频 、直播等等

TCP 提供⾯向连接的服务。在传送数据之前必须先建⽴连接，数据传送结束后要释放连接。 TCP 不提
供⼴播或多播服务。（TCP的可靠体现在TCP在传递数据之前，会有三次握⼿来建⽴连接，⽽且在数据传递时，有确认、窗⼝、重传、拥塞控制机制，在数据传完后，还会断开连接⽤来节约系统资源），这⼀难以避免增加了许多开销，TCP ⼀般⽤于⽂件传输、发送和接收邮件、远程登录等场景

TCP对于UDP来说更安全，但是占用资源更多，速度更慢，所以UDP一般用来qq视频直播等，TCP用来传输文件、邮件等；

TCP 协议如何保证可靠传输：

TCP建立可靠连接的方式有：序列号/确认应答、校验和、流量控制、拥塞控制、ARQ协议（类似3次握手）、超时重传

1. 应⽤数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每⼀个包进⾏编号，接收⽅对数据包进⾏排序，把有序数据传送给应⽤层。
3. 校验和： TCP 将保持它⾸部和数据的检验和。这是⼀个端到端的检验和，⽬的是检测数据在传
   输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报⽂段和不确认收到此报⽂
   段。
4. TCP 的接收端会丢弃重复的数据。
5. 流量控制： TCP 连接的每⼀⽅都有固定⼤⼩的缓冲空间，TCP的接收端只允许发送端发送接收端
   缓冲区能接纳的数据。当接收⽅来不及处理发送⽅的数据，能提示发送⽅降低发送的速率，防⽌
   包丢失。TCP 使⽤的流量控制协议是可变⼤⼩的滑动窗⼝协议。 （TCP 利⽤滑动窗⼝实现流量
   控制）
6. 拥塞控制： 当⽹络拥塞时，减少数据的发送。
7. ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对⽅
   确认。在收到确认后再发下⼀个分组。
8. 超时重传： 超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。在重发的过程中，假如一个包经过多次的重发也没有收到对端的确认包，那么就会认为接收端异常，强制关闭连接。并且通知应用通信异常强行终止。

  

##### 在浏览器中输⼊url地址 ->> 显示主⻚的过程(⾯试常客)

  1、浏览器中输入url地址后首先会进行DNS解析，找到真实的IP地址，因为互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以要先进行翻译，实现网址到IP地址的转换；

  查找的过程是一个递归查询的过程，首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地；

  第二就是建立TCP连接，也就是三次握手跟四次挥手；

  然后发出Http请求，HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文；

  服务器接收到Http请求，进行处理后返回页面所属于数据（转换为json格式）；页面收到这个Http响应后，会一个一个的响应出用户请求的页面（也就是载⼊解析到的资源⽂件，渲染⻚⾯），这个页面里面有表格，有图片，有文字，也可能有视频等等 。

### HTTP

##### HTTP是不保存状态的协议,如何保存⽤户状态

  HTTP 是⼀种不保存状态，即⽆状态（stateless）协议。也就是说 HTTP 协议⾃身不对请求和响应之间
  的通信状态进⾏保存，Session 机制的存在就是为了解决这个问题，Session 的主要作⽤就是通过服务端记录⽤户的状态。典型的场景是购物⻋，当用户要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作的，因为 HTTP 协议是⽆状态的。所以我们使用session机制，服务端给特定的⽤户创建特定的Session 之后就可以标识这个⽤户并且跟踪这个⽤户了（⼀般情况下，服务器会在⼀定时间内保存这个Session，过了时间限制，就会销毁这个Session）。对于实现 Session 跟踪呢？⼤部分情况下，我们都是通过在
  Cookie 中附加⼀个 Session ID 的⽅式来跟踪。

##### Http各版本的区别：

  在HTTP/1.0中默认使⽤短连接。也就是说，浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接（无连接），服务器不跟踪每个客户单，也不记录过去的请求（无状态）。

  缺点：

  1、无法复用连接：HTTP/1.0每次发生请求，都需要重新建立连接，而TCP的连接释放工程很耗时，会使网络的利用率变低

  2、队头阻塞，由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。

##### HTTP1.0之后

  HTTP/1.1、HTTP/2.0都使用了长连接，使⽤⻓连接的HTTP协议，会在响应头加⼊这⾏代码Connection:keep-alive

  在使⽤⻓连接的情况下，当⼀个⽹⻚打开完成后，客户端和服务器之间⽤于传输HTTP数据的TCP连接不
  会关闭，客户端再次访问这个服务器时，会继续使⽤这⼀条已经建⽴的连接。Keep-Alive不会永久保持
  连接，它有⼀个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现⻓连接需要客
  户端和服务端都⽀持⻓连接，增加了错误状态码，缓存处理，带宽优化和网络连接的使用

  错误状态响应码 :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源
  与资源的当前状态发⽣冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

3. 缓存处理 :在HTTP1.0中主要使⽤header⾥的If-Modified-Since,Expires来做为缓存判断的标

```
准，HTTP1.1则引⼊了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match,
If-None-Match等更多可供选择的缓存头来控制缓存策略。
```

4. 带宽优化及⽹络连接的使⽤ :HTTP1.0中，存在⼀些浪费带宽的现象，例如客户端只是需要某个

```
对象的⼀部分，⽽服务器却将整个对象送过来了，并且不⽀持断点续传功能，HTTP1.1则在请求
头引⼊了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这
样就⽅便了开发者⾃由的选择以便于充分利⽤带宽和连接。
```



##### HTTP 和 HTTPS 的区别？

1. 端⼝ ：HTTP的URL由“http://”起始且默认使⽤端⼝80，⽽HTTPS的URL由“https://”起始且默认

```
使⽤端⼝443。
```

2. 安全性和资源消耗： HTTP 是超文本传输协议，连接很简单，是无状态的，运⾏在TCP之上，所有传输的内容都是明⽂，而HTTPS协议是由 SSL+HTTP 协议构建，所有传输的内容都经过加密，比Http协议更安全；虽然HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP耗费更多服务器资源。
3. HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(比如官网一般是http，邮箱是 https 。)