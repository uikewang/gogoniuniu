##### 自我结束，

⾯试官，您好！我叫王科杰。我的专业是物联网工程，在⼤学期间里主要学习了 Java 、c等编程语言、以及 Spring和MyBatis等框架 。我曾因为学习成绩优先在大二时获得国家励志奖学金，在校期间我参与过⼀个大型的项目的开发，参与了海南新一代云网资源中心资源平台这个系统的开发到上线的全过程。我在其中的职责是后端开发，主要负责了app功能模块的搭建，做好app端的功能实现，以及定位一些bug寻找解决方法。另外在项目里，我还参与了对系统进行了压力测试的工作，学习了jmeter工具的使用和linux服务器的使用。在大学里面我也自主的上网学习了一些如瑞吉外卖等项目，可能在校期间我的能力并不足够完成公司的具体业务要求，但是我相信我的的学习能力可以快速上手公司的任务要求；



自我介绍：

你好 我叫王科杰 我就读于海南大学物联网工程专业，今年6月份毕业，在接触物联网这个专业以后，我一直软件编程方面很感兴趣，我比较擅长的技术栈是：Java、springmvc、mysql数据库等，在校期间也会在网上学习开发一些项目，锻炼自己的编程能力，我所找的实习岗位也是后端开发，在实习过程中我也了解到了工作的流程，一个项目是如何从开发到上线；

为什么选择我们公司

首先是公司的岗位非常符合我的职业发展，在网上投递资料的时候我觉得公司这个岗位很适合我，加上自己本身学的就是这个专业，很适合这个岗位，也希望可以有幸进入公司发展；

其次我在网上有查阅了公司的资料，发现不管是管理模式还是工作氛围都十分吸引我

##### 职业规划：

虽然我目前还在大学阶段，但也仔细想过自己的职业规划，这里可以分为3个阶段

第一个阶段是成长期；在毕业到工作的一年内，我希望我可以快速将毕业生的身份转化为职场人士，快速熟悉行业和业务，让自己的能力快速达到工作的标准；

第二个阶段是发展期，我希望在三到五年内可以在我所在的行业技术上越来越好，可以接触到团队的核心业务，不断提升自己的能力，让工作效率越来越高，同时也可以给公司带来更大的价值；

第三个阶段现在距离我还比较遥远，在这个阶段我希望我可以在团队里独当一面，做到独立带项目或团队的能力；

##### 优点和缺点：

1、我最大的优点我可以接受新事务，对于不懂的东西我有强烈的好奇心，比如在公司实习时，由于项目进展紧张，公司安排了一个接口压测的任务，这是我没有接触过的，但我也可以去上网查阅资源，询问部门的人员请求帮助，最终完成公司的任务；

缺点：

1、我的缺点是有点急燥，容易急于求成，但现在我学会把任务分成多个部分，可以有序的安排完成，而不是一股脑上

2、由于是应届生，在工作上我对于业务接触得比较少，但在以后我相信这个问题会有所改善；

##### 你能接受公司加班吗

对的，我接受加班，作为新人加入一个岗位我觉得加班是很正常的，因为公司的业务一般都特别复杂，不懂业务的话会让工作进展困难，所以我会在初期用更多的时间来学习公司的业务，提升自己的工作效率；

公司是经常加班吗？hr：没有，只是有些时候工作比较紧，会加班比较多；

嗯嗯，那是没有问题的，本身我就是新人，在工作中应该多学多看，这样才能让我更快的成长，本身我也是团队的一份子，所以在工作量多的时候，我觉得加班我是完成愿意的；

##### 你期望的薪资是多少：

1、因为我不知道我们公司的具体薪资结构，包括绩效、年终奖、福利等，这我不太好说，不过我期望的薪资是能在这个行业的平均值这里；

2、在投递公司时，我在平台上来有了解到一些基本的的薪资情况，我希望可以拿到。。。。这样一个薪资（在公司给出的薪资范围）

##### 问公司的？

1、接下来的面试流程是怎么样安排的，大概什么时候会有结果；

2、公司的培养机制是怎么样的；

3、进入公司后会有试用期吗？   如果有，加问：大概需要试用多久，转正的标准是怎么样的；

4、如果有辛入职，我需要提前了解和准备什么吗



1、我们部分负责的业务是什么

##### 在实习过程中所做的事情：

在实习中我担任的角色是后端开发，主要负责的是智慧营维app后端的开发，我需要根据页面想要实现的效果来编写代码，编写逻辑并调用数据库返回数据给前端，比如实现光纤光路模块，业务需求是需要在点击后可以选择光路的类型，并根据名字或编码进行查询，显示出地址和相关信息，我主要是在后台编写一个接口，来接收前端的请求，并进行代码编写，返回需要的数据；

##### 在开发过程中我遇到的困难

1、在项目中用到了唯一ID生成器.生成出的ID是long型的(比如说4616189619433466044).但是通过某个rest接口中返回json数据后,发现浏览器解析完变成了4616189619433466000，出现数据不一致的情况，原因是long能表示的范围比js中的number还要大，需要改成String类型存储，可以解决这个问题；

2、在学校里的时候我做过一个购物网站的项目，在开发的时候我遇到一个技术难度，那就是如何处理大量并发请求，因为购物平台会有很多用户同时购买的情况，同一时间可能有数千人在线购物，如果不能处理这个并发请求，会导致网站的响应非常的慢，用户体验会受到影响；我们当时采用了多线程技术，分配任务给不同的线程，提高系统的并发处理能力；另外我们还使用了缓存技术，缓存常用的数据，减少对数据库的处理，并对请求使用队列技术，对请求进行排队，以保证系统的稳定性。

此外，我们还不断地进行性能监控和优化，以保证系统能够应对不断增长的用户量和请求量。最后，我们还进行了接口压力测试，确保并发控制机制的可靠性、效率和稳定性，以确保多线程应用功能的正确性和性能；







##### 什么是java？

java是一种面向对象的编程语言，由sun公司开发，后被orcle公司收购，java具有跨平台的特性。可以在不同的操作系统上进行运行，java语言具有封装、继承、多态的基本概念，表面java程序具有良好的重用性和可扩展性，java语言具有良好的可读性、可移植性、可扩展性，而面向对象指的是将现实世界中事物抽象为对象，通过对象之间的相互交互来完成程序设计；面向对象可以设计出低耦合的系统，但性能不及面向过程，所以嵌入式、linux开发等会使用面向过程，性能比面向过程低是因为Java 是半编译语⾔，最终的执⾏代码并不是可以直接被 CPU 执⾏的⼆进制机械码，⽽⾯向过程语⾔⼤多都是直接编译成机械码在电脑上执⾏

##### 描述一下封装：

封装是面向对象的基本概念，用于隐藏对象的细节，提供统一的接口给外部使用，这样可以避免对象的状态被破坏，使代码更加清晰和易于维护，在项目中很多时候我们都会使用到封装，比如一个员工对象，我们把的基本信息封装起来，然后在controller层进 行调用，这样可以避免了我们的代码冗余，方便阅读，同时也保护了内部的数据；

##### 那继承跟多态呢？

继承跟多态都是面向对象的基本概念，继承是子类可以继承父类的方法跟属性，进行调用，也可以通过覆盖或重写的方式来修改或者扩展父类，继承可以减少代码重复，提高代码的可维护性和可扩展性

多态是不同的对象类型可以对同一消息做出不同的响应，多态由继承和接口实现，多态：子类必须对父类方法重写，通过父类的引用去调用重写方法，必须在继承的关系下；由于java语言的继承跟多态，节省了我们编写代码时间，使代码逻辑更加清楚。

重载：在一个类里面定义多个方法，这些方法名字相同，但参数和参数个数不同，可以根据参数和参数个数来选择不同的方法，重写：在子类中定义一个与父类同名的方法，参数列表和返回值类型相同，但是可以修改或者扩展父类的方法； 

1、如果⽗类⽅法访问修饰符为 private/final/static 则⼦类就不能重写该⽅法，但是被 static修饰的⽅法能够被再次声明。

2、构造⽅法⽆法被重写

##### 那你知道什么是泛型吗？

泛型是java5中新增的特性，通过使用泛型可以在编译时检查类型安全，避免在运行时出现类型错误。泛型的本质是为了**参数化类型**（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）

##### 泛型的规定：

包装类型可用于泛型，而基本类型不可以。泛型不能使用基本类型，因为使用基本类型时会编译出错。

##### 自动装箱和拆箱呢：

也是java5中新增的特性，自动装箱是指将基本数据类型自动转换为对应的包装类型，而拆箱则是将包装类型转换为对应的基本数据类型

![1694505992156](D:/Program file/typora/img/1694505992156.png)

##### 你了解java中的异常吗？

异常是java中的一种错误机制，用于处理程序中发生的异常情况，异常分为受检异常和非受检异常，受检异常需要在方法签名中进行声明，用于处理或抛出异常，非受检异常不需要在方法签名中进行声明，可以在任何地方抛出

##### Error 和 Exception 区别是什么？

Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类 `Exception`（异常）和 `Error`（错误）。

`Exception` 和 `Error` 二者都是 Java 异常处理的重要子类，各自都包含大量子类。

- **Exception** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。`Exception` 又可以分为受检异常和非受检异常) 。
- **Error** ：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。

##### throws 关键字和 throw 关键字在使用上的几点区别如下：

- throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。
- throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。

##### 你了解集合吗？

集合是java中的一种数据结构，用来存储一组对象，分为list、set、map三种类型，list用来存储有序元素，可以重复；set用来存储无序元素，不可以重复；map用来存储键值对，键不可以重复；

其中List 提供了一组操作序列的方法，可以通过索引访问元素，可以实现栈、队列、链表等数据结构。Set 提供了一组操作集合的方法，可以实现交、并、差等集合运算。Map 提供了一组操作键值对的方法，可以实现字典、哈希表等数据结构。

##### 你说一下线程：

线程是程序执行的最小单位，是进程中的一个独立执行流，可以同时执行多线程，实现多任务处理；

而多线程是指一个进程可以包括一个或者多个线程，每个线程可以独立执行不同的任务，实现多任务处理，在java中多线程用Thread类和Runable接口实现，多线程可以提高程序并行和效率，但同时也会带来线程安全问题； 

**Java线程具有五中基本状态**

**1）新建状态（New）**：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();

**2）就绪状态（Runnable）**：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；

**3）运行状态（Running）**：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；

**4）阻塞状态（Blocked）**：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：

1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；

2.同步阻塞 — 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；

3.其他阻塞 — 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时. join()等待线程终止或者超时. 或者I/O处理完毕时，线程重新转入就绪状态。

**5）死亡状态（Dead）**：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

##### 怎么开启一个线程

在Java中，有多种方法可以开启一个线程。以下是其中三种方法：

1. 继承Thread类

- 定义一个继承自Java.lang.Thread类的类
- 覆盖该类的run方法
- 在run方法中编写需要执行的操作：run方法中的代码，线程执行体
- 在main方法（线程）中，创建一个该类的实例，即创建线程对象
- 调用线程对象的start()方法来启动该线程

1. 实现Runnable接口

- 定义一个实现Runnable接口的类
- 在该类中实现run()方法
- 在main方法（线程）中，创建一个实现Runnable接口的对象，并将其作为参数传递给Thread类的构造函数
- 调用Thread对象的start()方法来启动该线程

1. 匿名内部类

- 在main方法（线程）中，创建一个匿名内部类的对象
- 将该匿名内部类对象作为参数传递给Thread类的构造函数
- 调用Thread对象的start()方法来启动该线程

##### 2.3.4. 为什么要使⽤多线程呢?

先从总体上来说：
从计算机底层来说： 线程可以⽐作是轻量级的进程，是程序执⾏的最⼩单位,线程间的切换和调度的成本远远⼩于进程。另外，多核 CPU 时代意味着多个线程可以同时运⾏，这减少了线程上下⽂切换的开销。
从当代互联⽹发展趋势来说： 现在的系统动不动就要求百万级甚⾄千万级的并发量，⽽多线程并发编程正是开发⾼并发系统的基础，利⽤好多线程机制可以⼤⼤提⾼系统整体的并发能⼒以及性能。
再深⼊到计算机底层来探讨：
单核时代： 在单核时代多线程主要是为了提⾼ CPU 和 IO 设备的综合利⽤率。举个例⼦：当只有⼀个线程的时候会导致 CPU 计算时，IO 设备空闲；进⾏ IO 操作时，CPU 空闲。我们可以简单地说这两者的利⽤率⽬前都是 50%左右。但是当有两个线程的时候就不⼀样了，当⼀个线程执⾏ CPU 计算时，另外⼀个线程可以进⾏ IO 操作，这样两个的利⽤率就可以在理想情况下达到100%了。
多核时代: 多核时代多线程主要是为了提⾼ CPU 利⽤率。举个例⼦：假如我们要计算⼀个复杂的任务，我们只⽤⼀个线程的话，CPU 只会⼀个 CPU 核⼼被利⽤到，⽽创建多个线程就可以让多个 CPU 核⼼被利⽤到，这样就提⾼了 CPU 的利⽤率

##### 2.3.5. 使⽤多线程可能带来什么问题?

并发编程的⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度，但是并发编程并不总是能提⾼程序运⾏速度的，⽽且并发编程可能会遇到很多问题，⽐如：内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题。

带来线程不安全是由于在多线程环境下，程序可能会发生数据并发等问题，导致程序不能正确执行或产生错误结果；因此线程不安全的程序可以同步来进行处理，同步是指在多线程环境下，通过对共享资源的访问进行协调和处理，以确保多个线程之间的操作能够正常执行，保护了线程安全和数据一致性；

实现线程同步可以使用synchronized关键字、lock接口、volatile关键字、原子类；

##### 那什么是线程池呢？

线程池是一种管理和复用线程的机制，可以提高多线程程序的性能和复用性；它可以预先创建一些线程，并且维护一个任务队列，当有新的任务需要执行时，就会将任务添加到任务队列中，然后由空闲的线程来执行任务。使用线程池可以避免重复创建和销毁线程的开销，提⾼响应速度，提⾼线程的可管理性，从而提高系统的性能

线程池的工作原理如下：

初始化线程池，创建一定数量的线程，并将它们置于等待状态。
当有新的任务到来时，线程池会将任务添加到任务队列中。
空闲线程会从任务队列中取出任务并执行，直到任务队列为空。
如果任务队列为空，空闲线程会继续等待新的任务到来。
如果任务队列已满，并且所有的线程都在执行任务，线程池会根据配置的策略来处理任务，如阻塞、抛弃等。

线程池中的核心线程数是线程池中最小的线程数，即使线程池中没有任务，核心线程也会一直存在，直到线程池被关闭。最大线程数是线程池中最大的线程数，当任务数量超过核心线程数时，线程池会创建新的线程来处理任务，直到线程数量达到最大线程数为止。

1、execute() ⽅法⽤于提交不需要返回值的任务，所以⽆法判断任务是否被线程池执⾏成功与
否；

2、submit() ⽅法⽤于提交需要返回值的任务。线程池会返回⼀个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执⾏成功

死锁：

多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止；

##### 死锁必须具备以下四个条件

- 互斥条件：该资源任意一个时刻只由一个线程占用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
- 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

##### 说一下jvm：

jvm：java虚拟机，一种抽象化的[计算](https://activity.huaweicloud.com/free_test/index.html?utm_source=hwc-csdn&utm_medium=share-op&utm_campaign=&utm_content=&utm_term=&utm_adplace=AdPlace070851)机;

Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。

JVM 可以理解的代码就叫做 字节码 （即扩展名为 .class 的⽂件），它不⾯向任何特定的处理器，只⾯向虚拟机。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问题，同时⼜保留了解释型语⾔可移植的特点。所以 Java 程序运⾏时更加⾼效

##### JVM、JRE和JDK的关系是什么？

JDK是（Java Development Kit）的缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

JRE是Java Runtime Environment缩写，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。

JDK包含JRE，JRE包含JVM。

##### Java 和 C++ 的区别?

虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：

- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。
- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）
- C语言的字符或字符串也是以数组进行存储的，结尾有一个/0表示结束，而java语言中没有；
- Java 不支持 C++ 中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。

##### 说一下final关键字

final关键字可以用于成员变量、本地变量、方法以及类，final 修饰的变量必须初始化，通常称被修饰的变量为`常量`，不能对final变量再次赋值，final的方法不能被重写，但子类可以使用该方法，final的类不能被继承；

final还可以用在异常处理里面，它只能在 `try/catch` 语句中，并且附带一个语句块表示这段语句最终一定被执行（无论是否抛出异常）

##### 说一下static关键字

通常来说，用new创建类的对象时，数据存储空间才被分配，方法才供外界调用。但有时我们只想为特定域分配单一存储空间，不考虑要创建多少对象或者说根本就不创建任何对象，再就是我们想在没有创建对象的情况下也想调用方法。

##### string为什么是不可变的

String 类中使⽤ final 关键字修饰字符数组来保存字符串， private final char value[] ，所以 String 对象是不可变的。所以在使用HashMap时常用String类型的常量来做key，它的hashcode会被缓存下来，所以相比于其他对象速度更快

##### String StringBuffer 和 StringBuilder 的区别是什么

⽽ StringBuilder 与 StringBuffer 都继承⾃ AbstractStringBuilder 类，在AbstractStringBuilder 中也是使⽤字符数组保存字符串但是没有⽤ final 关键字修饰，所以这两种对象都是可变的。

在线程安全上

String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是StringBuilder 与 StringBuffer 的公共⽗类，定义了⼀些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共⽅法。StringBuffer 对⽅法加了同步锁或者对调⽤的⽅法加了同步锁，所以是线程安全的。StringBuilder 并没有对⽅法进⾏加同步锁，所以是⾮线程安全的。

在性能方面：

每次对 String 类型进⾏改变的时候，都会⽣成⼀个新的 String 对象，然后将指针指向新的 String对象，StringBuffer 每次都会对 StringBuffer 对象本身进⾏操作，⽽不是⽣成新的对象并改变对象引⽤。相同情况下使⽤ StringBuilder 相⽐使⽤ StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的⻛险。

所以操作少量的数据: 适⽤ String

单线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder

多线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer

##### 浅拷贝和深拷贝的区别：

**浅拷贝**

- 对于基本数据类型的成员变量，浅拷贝直接进行值传递，也就是将属性值复制了一份给新的成员变量
- 对于引用数据类型的成员变量，比如成员变量是数组、某个类的对象等，浅拷贝就是引用的传递，也就是将成员变量的引用（内存地址）复制了一份给新的成员变量，他们指向的是同一个事例。在一个对象修改成员变量的值时，会影响到另一个对象中成员变量的值。

**深拷贝**

- 对于基本数据类型，深拷贝复制所有基本数据类型的成员变量的值
- 对于引用数据类型的成员变量，深拷贝申请新的存储空间，并复制该引用对象所引用的对象，也就是将整个对象复制下来。所以在一个对象修改成员变量的值，不会影响到另一个对象成员变量的值。

##### 接口和抽象类的差别：

1、接口的方法默认是public，所以方法在接口中不能实现，java8开始可以实现部分方法，而抽象类可以有非抽象方法

2、接⼝中除了 static、final 变量，不能有其他变量，⽽抽象类中则不⼀定。

3、⼀个类可以实现多个接⼝，但只能实现⼀个抽象类。接⼝⾃⼰本身可以通过 extends 关键字扩展多个接⼝。

4、接⼝⽅法默认修饰符是 public，抽象⽅法可以有 public、protected 和 default 这些修饰符
（抽象⽅法就是为了被重写所以不能使⽤ private 关键字修饰！）。

5、从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接⼝是对⾏为的抽象，是⼀种⾏为的
规范。

##### == 与 equals(重要)

== : 它的作⽤是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象(基本数据类型
==比较的是值，引⽤数据类型==比较的是内存地址)。
equals() : 它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：
情况 1：类没有覆盖 equals() ⽅法。则通过 equals() ⽐᫾该类的两个对象时，等价于通过
==比较这两个对象。
情况 2：类覆盖了 equals() ⽅法。⼀般，我们都覆盖 equals() ⽅法来⽐᫾两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

##### HashCode（）介绍：

hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个 int 整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java中的任何类都包含有 hashCode() 函数。
散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利⽤到了散列码！（可以快速找到所需要的对象）

##### 为什么要有 hashCode

 当把对象加⼊ HashSet时，HashSet 会先计算对象的 hashcode 值来判断对象加⼊的位置，同时也会与该位置其他已经加⼊的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调⽤ equals() ⽅法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。这样我们就⼤⼤减少了equals 的次数，相应就⼤⼤提⾼了执⾏速度。
通过我们可以看出： hashCode() 的作⽤就是获取哈希码，也称为散列码；它实际上是返回⼀个 int整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode() 在散列表中才有⽤，在其它情况下没⽤。在散列表中 hashCode() 的作⽤是获取对象的散列码，进⽽确定该对象在散列表中的位置。
hashCode（）与 equals（）的相关规定

1. 如果两个对象相等，则 hashcode ⼀定也是相同的
2. 两个对象相等,对两个对象分别调⽤ equals ⽅法都返回 true
3. 两个对象有相同的 hashcode 值，它们也不⼀定是相等的
4. 因此，equals ⽅法被覆盖过，则 hashCode ⽅法也必须被覆盖
5. hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode()，则该 class
   的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据

##### hashCode 与 equals (重要)

⾯试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode
⽅法？”

​	如果只重写了equals方法，而不重写hashcode的方法，会造成hashcode的值不同，而equals()方法判断出来的结果为true。

​	在Java中的一些容器中，不允许有两个完全相同的对象，插入的时候，如果判断相同则会进行覆盖。这时候如果只重写了equals（）的方法，而不重写hashcode的方法，Object中hashcode是根据对象的存储地址转换而形成的一个哈希值。这时候就有可能因为没有重写hashcode方法，造成相同的对象散列到不同的位置而造成对象的不能覆盖的问题



  ##### 字符型常量和字符串常量的区别？

  1. 形式上: 字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符；
  2. 含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置，相当于对象；
  3. 占内存大小：字符常量只占2个字节；字符串常量占若干个字节(至少一个字符结束标志) (注意: char 在Java中占两个字节)。

##### 什么是字符串常量池？

​	jvm为了提升性能和减少内存开销，避免字符的重复创建，其维护了一块特殊的内存空间，即字符串池，当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符串常量池中

比如String str=“aaa”，String str=new String（“aaa”），第一个语句程序运行时会在常量池中查找”aaa”字符串，若没有，会将”aaa”字符串放进常量池，再将其地址赋给str；若有，将找到的”aaa”字符串的地址赋给str。

而使用String str = new String("aaa");`，程序会在堆内存中开辟一片新空间存放新对象，同时会将”aaa”字符串放入常量池，相当于创建了两个对象，无论常量池中有没有”aaa”字符串，程序都会在堆内存中开辟一片新空间存放新对象。

##### String是基本数据类型吗？

​	不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了这些基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。

##### 什么是序列化？

​	序列化是将对象的状态保存到文件或者网络中，以便后续恢复。Java 中的序列化使用 ObjectOutputStream 进行对象序列化，使用 ObjectInputStream 进行对象反序列化。序列化可以用于数据持久化、远程通信等场景

对于不想进⾏序列化的变量，使⽤ transient 关键字修饰。（静态变量本身就不会被序列化，静态变量优先于对象存在, 随着类的加载而加载）
transient 关键字的作⽤是：阻⽌实例中那些⽤此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和⽅法。

##### volatile的使用：

在java1.2之前，java的内存模型总是从主存中进行读写，是没有问题的，但是在现在，线程可以把变量保存在本地内存，这就可能导致一个线程在内存中修改了值，但是另一个线程还使用它在寄存器中的值，造成数据不一致，这就需要我们使用volatile，声明这个变量是不稳定的，需要到内存中进行读取；

volatile和synchronized区别：

1、volatile关键字是线程同步的轻量级实现，所以volatile性能肯定⽐synchronized关键字要好。
但是volatile关键字只能⽤于变量⽽synchronized关键字可以修饰⽅法以及代码块。

2、多线程访问volatile关键字不会发生阻塞，而访问synchronnized关键字可能会发生阻塞

3、volatile关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized关键字解决的是多个线程之间访问资源的同步性

##### Java 中 IO 流分为⼏种?

按照流的流向分，可以分为输⼊流和输出流；
按照操作单元划分，可以划分为字节流和字符流；
按照流的⻆⾊划分为节点流和处理流。

InputStream/Reader: 所有的输⼊流的基类，

OutputStream/Writer: 所有输出流的基类，

##### 既然有了字节流,为什么还要有字符流?

问题本质想问：不管是⽂件读写还是⽹络发送接收，信息的最⼩存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？
回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是⾮常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就⼲脆提供了⼀个直接操作字符的接⼝，⽅便我们平时对字符进⾏流操作。如果⾳频⽂件、图⽚等媒体⽂件⽤字节流⽐字符流好，如果涉及到字符的话使⽤字符流比较好

##### 线程安全的集合有哪些？线程不安全的呢？

线程安全的：

- Hashtable：比HashMap多了个线程安全。
- ConcurrentHashMap:是一种高效但是线程安全的集合。
- Vector：比Arraylist多了个同步化机制。
- Stack：栈，也是线程安全的，继承于Vector。

线性不安全的：

- HashMap
- Arraylist
- LinkedList
- HashSet
- TreeSet
- TreeMap

##### Arraylist 与 LinkedList 区别?

​			1.是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保				证线程安全

2. 底层数据结构： Arraylist 底层使⽤的是 Object 数组； LinkedList 底层使⽤的是双向链表 数据结构

3. 插⼊和删除是否受元素位置的影响： ① ArrayList 采⽤数组存储，所以插⼊和删除元素的时间复杂度受元素位置的影响。 ② LinkedList 采⽤链表存储，所以对于 add(E e) ⽅法的插⼊，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置 i 插⼊和删除元素的话（ (add(int index, E element) ） 时间复杂度近似为 o(n)) 因为需要先移动到指定位置再插⼊
   
4. 是否⽀持快速随机访问： LinkedList 不⽀持⾼效的随机元素访问，⽽ ArrayList ⽀持。快速随机访问就是通过元素的序号快速获取元素对象(对应于 get(int index) ⽅法)。

5. 内存空间占⽤： ArrayList的空 间浪费主要体现在在list列表的结尾会预留⼀定的容量空间，⽽LinkedList的空间花费则体现在它的每⼀个元素都需要消耗⽐ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）

  ##### 为什么要用arraylist取代vector

  Vector 类的所有⽅法都是同步的。可以由两个线程安全地访问⼀个Vector对象、但是⼀个线程访问Vector的话代码要在同步操作上耗费⼤量的时间。
  Arraylist 不是同步的，所以在不需要保证线程安全时建议使⽤Arraylist。需要线程安全时使用Vector

##### 为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?

因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。

因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。

##### 说一说sleep（）和wait（）的相同点和区别：

两者最大的区别在于sleep方法不会释放锁，而wait方法会释放锁

两者都可以用来线程暂停，但sleep可以自动唤醒，但wait（）不会自动唤醒，需要等待别的线程调用notify（）或者notifyall（）才能唤醒；sleep通常用来线程暂停执行，wait通常用来线程间交互和通信、

##### 2.3.10. 为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？

这是另⼀个⾮常经典的 java 多线程⾯试问题，⽽且在⾯试中会经常被问到。很简单，但是很多⼈都会
答不上来！
new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。总结： 调⽤ start ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ run ⽅法只是 thread 的⼀个普通⽅法调⽤，还是在主线程⾥执⾏。

程序计数器：

1. 字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执⾏、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置，从⽽当线程被切换回来的时候能够知道该线程上次运⾏到哪⼉了。

##### 相关的注入注解：

**@Autowired**:

- 解释：@Autowired 是 Spring 提供的最常用的自动装配注解之一。它可以用于自动注入依赖关系，通常与构造函数、setter 方法或字段一起使用。当 Spring 容器启动时，它会自动查找匹配类型的 Bean 并将其注入到标注了 @Autowired 的位置。

**@Value**:

- 解释：@Value 注解用于注入外部配置属性的值。你可以将属性值直接注入到字段、构造函数参数或方法参数中，并且可以使用 SpEL 表达式。

**@Resource**:

- 解释：@Resource 是	 Java EE 的注解，也可以用于 Spring 中，用于进行依赖注入。它支持按名称或类型自动装配 Bean，并且可以指定 Bean 的名称。

# mysql

##### 三大范式：

数据库三范式（[Normalization](https://so.csdn.net/so/search?q=Normalization&spm=1001.2101.3001.7020)）是数据库设计中的一种规范标准，旨在减少数据冗余并建立结构合理的数据库，以提高数据存储和使用的性能。三范式是按照数据依赖性的程度来划分的，包括第一范式（1NF）、第二范式（2NF）和第三范式（3NF）。

第一范式：要求关系型数据库中的每个列都必须是原子的，即每列的值不能再分解成其他几列。遵循原子性。即，**表中字段的数据，不可以再拆分**

第二范式(2NF)：满足第一范式；且不存在部分依赖，即非主属性必须完全依赖于主属性。(主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分)；通俗一点讲就是一个表只能描述一件事情

第三范式(3NF)：满足第二范式；且不存在传递依赖，即非主属性不能与非主属性之间有依赖关系，非主属性必须直接依赖于主属性，不能间接依赖主属性。任何非主属性不依赖于其它非主属性（A -> B, B ->C, A -> C）即，**在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B**

通过遵循数据库三范式，可以减少数据冗余、提高数据库的整体性能、简化数据维护和更新操作，并确保数据的一致性和完整性。

##### 描述一下数据库事务：

数据库事务是指由一组数据库操作序列构成的一个逻辑工作单元，要么全部执行成功，要么全部回滚，以保证数据的完整性和一致性

##### ACID是指事务必须满足的4个特性：

原子性（Atomicity）：一个事务中的所有操作必须全部成功或全部失败，不允许出现部分成功部分失败的情况。

一致性（Consistency）：事务的执行必须使数据库从一个一致性状态变换到另一个一致性状态，即事务执行前后，数据库的完整性约束没有被破坏。
隔离性（Isolation）：多个事务之间互相独立，彼此不可见。每个事务看到的数据都是自己的独立版本，不会受到其他事务的干扰。
持久性（Durability）：一旦事务提交成功，它对数据库中的数据的改变就是永久性的，即使系统崩溃，数据也不会丢失。

##### 事务的特性是什么，可以详细说一下吗？

事务的特性有原子性、一致性、隔离性、持久性；我用一个例子来说明吧，比如A向B转账500，转账成功，A扣除500，B就要增加500，这个原子操作要么全部成功，要么全部失败；

在转账的过程中，数据都要保持一致，A扣除500，B就必须要增加500，这就体现了一致性；

在转账过程中，隔离性体现在A像B转账，不能被其他事务干扰；

在转账过程中，持久性体现在事务提交后，对数据库的改变就是持久性的

##### 事务并发带来问题：

在我们在进行项目开 发时，多个事务并发是很常见的，但这可能会导致一些问题；

比如可能会带脏读问题，就是一个事务正在访问数据也对数据进行了修改，但这个修改并没有提交到数据库，而这时另一个事务访问数据库进行读取时，会读到这个修改的数据；

第二个是不可重复读问题，就是一个事务内多次访问数据库，这个事务还没有结束，但此时有另一个事务也访问了数据库，并进行修改数据，这时第一个事务会发生两次读取的数据不一致的情况；

第三就是幻读，它与不可重复读类似，就是在一个事务多次读取时会出现多出原本不存在的数据，就好像发生了幻觉一样；

##### 对事务并发带来的问题，我们可做什么呢；

我们应该对事务进行隔离；mysql支持4种隔离级别，分别是：未提交读，读已提交读，可重复读，串行化，其中我们最常使用的是可重复读，这也是mysql默认的隔离级别，它可以解决脏读和不可重复读，但不能解决幻读，而串行化可以解决全部问题，但是性能比较低；

##### MySQL 中的 varchar 和 char 有什么区别？

char 是一个定长字段,假如申请了`char(10)`的空间,那么无论实际存储多少内容.该字段都占用 10 个字符,而 varchar 是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.

在检索效率上来讲,char > varchar,因此在使用中,如果确定某个字段的值的长度,可以使用 char,否则应该尽量使用 varchar.例如存储用户 MD5 加密后的密码,则应该使用 char。

![1694510595295](D:/Program file/typora/img/1694510595295.png)

##### undo log和redo log的区别？

redo log日志记录的是数据页的物理变化，在服务怠机时用来同步数据，而undo log不同，它主要记录的是逻辑日志，当事务回滚时，可以逆操作恢复原来的数据；比如进行插入操作时，undo log会记录一个删除操作；redo log保证了事务的持久性，而undo log保证的是事务的原子性和一致性

##### 数据库的主从同步原理

主从同步就是主库的数据同步到从库的数据

mysql主从复制的核心就是二进制日志binlog

1、主库在事务提交时，会把数据变更记录在二进制日志文件中，

2、从库读取主库的二进制日志文件，写入到从库的中继日志，

3、从库重做中继日志中事件，将改变反映它自己的数据；

##### 主从同步的作用：

1、通过增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上向外提供读功能，

可以动态地调整从服务器的数量，从而调整整个数据库的性能。

2、提高数据安全-因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据

3、在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能

4、数据备份。一般我们都会做数据备份，可能是写定时任务，一些特殊行业可能还需要手动备份，有些行业要求备份和原数据不能在同一个地方，所以主从就能很好的解决这个问题，不仅备份及时，而且还可以多地备份，保证数据的安全

##### binlog作用？

MySQL的 binlog 是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。binlog 不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看 MySQL 执行过的所有语句。

MySQL binlog 以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。binlog 的主要目的是复制和恢复。

##### 你们项目有使用分库分表吗，具体怎么用的？

我们项目有用到分库分表，因为我们项目负责的是整个海南的云网业务，随着业务的增多，优化能提升的效果已经很小了，这次我们有用到分库分表，这样来突破io瓶颈、cpu瓶颈；我们使用的是水平分库，将一个库中的数据拆分到多个库中，解决海量数据存储和高并发的问题

**水平拆分**的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。

**垂直拆分**的意思，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。

##### 什么是索引？为什么要使用索引：

索引是一种数据结构，是帮忙数据库快速查找数据的数据结构，并且是有序的，结构采用B+树，用于提高数据库的查询速度。它可以在一个表中快速查找指定列的值。使用索引可以提高查询速度、排序速度和分组速度，减少磁盘I/O操作次数，节省查询时间，提高数据库性能。

索引列对数据进行排序，减低了数据排序的成本，减少了cpu的消耗；

通俗来讲索引就好比书本的目录，加快[数据库](https://activity.huaweicloud.com/dbs_Promotion/index.html?utm_source=hwc-csdn&utm_medium=share-op&utm_campaign=&utm_content=&utm_term=&utm_adplace=AdPlace070851)的查询速度

**索引的缺点**

- 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；
- 空间方面：索引需要占物理空间。

##### 在mysql中如何定位慢查询？

当页面加载过慢，或者在进行接口压测时间过长1、在公司里我们使用skywalking运维工具监控接口，通过这个软件我们可以快速定位是哪个接口更慢；2、在mysql中自带一个慢日志，我们在配置文件中进行开启后可以使用，在里面我们可以设置当sql执行超过多少秒时它会被记录在日志中

（当时在公司负责接口测试时，发现一个页面加载过慢，然后我通过请教组的阿哥得知我们公司是使用skywalking运维工具监控接口，在这个工具里我们可以快速定位是哪个接口更慢，并有跟踪功能，可以知道是不是sql语句执行过慢，还有一种方法是我们在mysql开启慢日志，这是mysql自带的，在里面我们可以设置当sql执行超过多少秒时，它会被记录在日志中）

##### 一个sql执行很慢，我们如何分析？

在我们实际开发过程中，我们通常通过mysql自动的执行计划explain或者DESC关键字来获取sql语句执行的相关信息，通过观察表格，

第一、我们可以通过key和key_len检查它是否有使用索引，是否命中

第二、我们可以通过type字段来判断它，属于什么查询类型，是否存在全索引扫描或全盘扫描，影响执行效率

第三、我们通过extra额外信息来判断是否出现回表情况，如果出现我们可以添加索引或者修改返回字段来进行修复；

##### 什么是B+树呢

B+树是在B树的基础上进行优化的，使其更适合外存储索引结构，B+树的非叶子结点并不存储数据，而是只存储指针，这样1、B+树磁盘读写代价更低，2、查询效率上B+更高，因为它可以通过顺序访问所有叶子节点来获取数据，而B-树只能通过查找操作来获取数据。3、因为B+树是双向指针进行连接的，所以B+树更便于扫库和区间查询

##### 红黑树你知道吗？

红黑树是由AVL树发展来的，也相当于是AVL树的进化版，AVL树是任何一个节点左子支高度与右子支高度之差的绝对值不超过1，这个规定太死了，实现起来困难，所以就出现红黑树，红黑树的节点是红色或黑色的，根是黑色的，所有的叶子都是黑色的	，每个红色节点必须有两个黑节点，红色节点不能连续，从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点；红黑树的基本操作与其他树差不多，都包括查找、增加、删除等操作，在进行这些操作的同时还要保存红黑树的规则，则就需要用到旋转操作、调色、调位操作等，旋转操作分为左旋和右旋，左旋是将某个节点旋转为其右孩子的左孩子，而右旋是节点旋转为其左孩子的右孩子

![1693907217103](D:/Program file/typora/img/1693907217103.png)



##### 了解索引的底层数据结构吗？（相等于说一下B+树）

1、数据库的InnoDB引擎采用的是B+树的数据结构来存储索引

B+树的阶数更多，路径更短；

在磁盘读写上B+代价更低，因为非叶子结点只存储指针，叶子结点才存储数据；

B+更便于扫库和区间查询，因为它是双向指针进行连接的，叶子结点是一个双向链表；

##### 有很多数据库都是采用进程的形式，你知道为什么吗

数据库采用进程的形式是因为多用户访问数据库时，需要保证数据的一致性和完整性。如果多个用户同时对同一个数据进行修改，可能会导致数据不一致的情况发生。而通过将每个用户的操作封装成一个独立的进程，可以避免多个用户之间的竞争条件和死锁等问题，从而保证数据的一致性和完整性。此外，进程还可以提高数据库的并发性和性能，因为每个进程都有自己的内存空间和资源限制，可以更好地利用计算机的硬件资源。



##### 什么是聚集索引，什么是二级索引（非聚集索引）

聚集索引是指数据和索引放在一块，B+树的索引叶子结点存储了整行数据；

二级索引是指数据和索引分开存储，B+树的叶子保存了对应的主键，可以有多个，但会产生一个问题就是二级索引并不能查找出全部数据，此时就会产生回表查询；

##### 什么是回表查询呢

通过二级索引查找对应的主键值，然后到聚集索引中查找整行的数据，这就是回表操作；

##### 覆盖索引呢？

是指查询时使用了索引，并且需要返回的列在该索引中能够全部找到；

1、我们可以使用id查询，它会直接走聚集索引，一次索引扫描，不用回表，性能更好；

2、如果按照二级索引查询数据，当前面返回的列数据并不能全部获得，则会触发回表查询，导致性能低，所以我们尽量不要使用select*，尽量在返回的列设置索引；

##### 超大分页你了解吗，如果出现怎么处理呢；

超大分页是指当数据量过大时，我们使用limit分页查询时，需要对数据进行排序，效率低，

这次我们可以使用覆盖索引跟子查询来解决，我们可以先分页查询id让它先进行覆盖索引，再使用子查询与原表id进行过滤，这样可以大大提升我们的性能



##### 索引创建的原则有哪些？

公司的项目有些表会存储大量的数据，表中的数据可能会超过10万条以上，这时我们就会创建索引，添加索引的原则有：添加索引的字段应当是使用比较频繁的字段，如作为查询条件、排序字段、分租字段这些，字段内容区分度高一些；

还有就是，在创建索引时我们应尽量使用复合索引，避免产生回表，这样会影响性能；

在某一个字段内容较长时，我们会考虑使用前缀索引，但是索引并不是越多越好，我们需要控制好索引的数量

##### 什么时候索引会失效？

我们可以通过使用mysql的自动执行计划explain来判断索引是否失效

##### 索引失效的情况：

比如，我们在使用索引时违反最左匹配原则，第二个是，模糊查询时如果%在索引前面也会导致索引失效，第三是如果我们在添加索引的字段上进行运算操作或者类型转换也都会导致索引失效；还有就是我在使用复合时，如果中间使用范围查询，也会导致后面的索引失效；

##### SQL优化的经验：

这个在日常还是很常见的，如果直说sql优化的话，我会从这几个方面进行考虑，比如建表时索引的选择，sql语句编写，主从分离、读写分离等，如果数据量很大，还可以进行分库分表；

##### 那你说一下你们具体怎么优化的

这个主要参考阿里出的那个开发手册《嵩山版》，比如，在选择字段的时候我们要根据字段内容选择合适的类型，比如是数值类型时，需要合适的选择tingint、int、bigint这些类型；

我们还可以在索引上进行优化，参考索引的创建原则，比如使用比较频繁的字段、唯一字段等作为索引，索引区分度高一点，尽量使用复合索引，避免产生回表；

在sql语言优化上，比如我们应尽量避免使用select *，指明出字段名称更好，还有就是要避免时索引失效的写法，比如在模糊查询时%不要加在在字段前面；还有就是如果是聚合查询，尽量使用union all代替union，这样效率更高；

##### 并发事务带来了哪些问题，怎么解决这些问题呢？

我们在项目开发的过程中，多个事务并发是经常发生的，并发也是必然的，这就可能会导致一些问题；

第一是脏读，当一个事务正在访问数据库并对数据进行修改，而这个修改并还没有提交到数据库中，这时另一个事务也访问了这个数据库，读到了这个修改的数据，因为上一个事务还没有提交，所以这时读到的数据为脏数据；

第二是不可重复读，比如一个事务内多次读取同一数据，这个事务还没有结束，另一个事务也访问了这个数据并进行修改（提交了），这时一个事务中两次读取到的数据是不一样的，这就是不可重复读；

第三是幻读，幻读与不可重复读类似，是一个事务多次读取时，读到了一些原本不存在的记录，所以称为欢读；

对于解决这个事务并发问题，我们可以采用隔离机制，mysql支持4种隔离机制，分别是未提交读，读已提交，可重复读，串行化，默认的隔离级别是可重复读，它能解决脏读和不可重复读，但是解决不了幻读；

##### 为什么要加锁?

当多个用户并发地存取数据时，在[数据库](https://cloud.tencent.com/solution/database?from=10680)中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。

保证多用户环境下保证数据库完整性和一致性。

##### 从锁的类别上分MySQL都有哪些锁呢？

从锁的类别上来讲，有共享锁和排他锁。

- 共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。
- 排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。

用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。

锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。

他们的加锁开销从大到小，并发能力也是从大到小。

#####  数据库的乐观锁和悲观锁是什么？怎么实现的？

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制
- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。







Spring框架：

##### spring框架中的单例bean是线程安全的吗？

不是线程安全的，spring框架中有一个@Scope注解，默认的值就是singleton，单例的。

因为一般在spring的bean的中都是注入无状态的对象，没有线程安全问题，如果在bean中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决；

##### 什么是AOP，你们项目中有没有使用到AOP

AOP是指面向对象编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合；

项目中使用到AOP：

记录操作日志，缓存，spring实现的事务；

核心是使用AOP中的环绕通知和切点表达式，通过环绕通知的参数获取请求方法的参数，获取到这些参数后，保存到数据库中；

##### spring中事务是如何实现的：

其本质就是通过AOP功能，在方法执行前后进行拦截，在执行方法前开启事务，在执行完目标方法之后根据执行情况进行提交事务或者回滚事务；

##### 在什么情况下spring中事务会失效；

1、异常捕获处理，自己处理了异常，没有抛出，这时事务有可能只进行了前一部分就结束了，导致事务失效，我们可以通过手动抛出异常进行处理；

2、抛出检查异常，因为spring默认只会回滚非检查异常， 我们可以通过配置rollbackFor属性来解决；

3、没有使用public方法导致的事务异常，spring为方法添加代理，添加事务通知等，前提条件都是public方法，我们可以把方法改为public方法来解决；

##### SpringMVC有了解吗，它的执行流程是怎么样的呢

首先用户会发送请求到前端控制器，前端控制器收到请求后调用处理器映射器，处理器映射器会去找到具体的处理器，生成具体的处理器对象和处理器拦截器，再一起返回给前端控制器，然后前端控制器会调用具体的处理器，并在方法上加上@ResponseBody，通过HttpMessageConverter来返回结果并转换为json响应；

##### Springboot自动配置原理你了解吗？

在Spring Boot项目中的引导类上会有一个@SpringBootApplication，这个注解对3个注解进行了封装，他们分别是@SpringbootConfiguration、@EnableautoConfiguration、@ComponentScan

其中@EnableAutoConfiguration是实现自动配置类的核心注解，该注解通过@import注解导入对应的配置选择器，内部就是读取了该项目和该项目引用的jar包的classpath路径下MeTA-INF/spring.factories文件中所配置类的全类名。在这些配置类中所定义的Bean会根据条件注解所指定的条件来决定是否将其导入到Spring容器中；

条件判断会有像@ConditionalOnClass这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类中所有的bean放入Spring容器中使用；























计算机网络：

##### 说一下三次握手:

三次握手是TCP协议用于建立可靠连接的过程，其步骤如下：

第一次握手（SYN）：客户端向服务器发送SYN包，标志位SYN置为1，请求建立连接。该包中包含一个随机生成的初始序列号ISN（Initial Sequence Number）。

第二次握手（SYN+ACK）：服务器收到SYN包后，由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，向客户端发送SYN+ACK包，表示同意建立连接。该包中也包含一个随机生成的序列号ISN，同时将确认序列号ACK设置为客户端的ISN+1。

第三次握手（ACK）：客户端收到服务器的SYN+ACK包后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，向服务器发送ACK包，表示客户端也同意建立连接。该包的序列号设置为服务器的ISN+1，确认序列号设置为服务器的ISN+1

在三次握手完成后，TCP连接建立成功，双方可以开始进行数据传输。这个过程可以确保连接的可靠性和完整性，防止数据包的丢失或重复传输

##### 背诵：

TCP/IP 协议是传输层的一个面向连接的安全可靠的一个传输协议，三次握手的机制是为了保证能建立一个安全可靠的连接，那么第一次握手是由客户端发起，客户端会向服务端发送一个报文，在报文里面：SYN标志位置为1，表示发起新的连接。当服务端收到这个报文之后就知道客户端要和我建立一个新的连接，于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack标志位置为1，表示确认客户端发起的第一次连接请求。以上两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。所以，还需要进行第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个ack标志位置1的确认消息。通过以上三次连接，不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。那么，这个连接就被安全的建立了

##### 四次挥手呢：

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

四次挥手原理：

第1次挥手：客户端打算断开连接，客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；

第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；

第3次挥手：服务器也打算断开连接，服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态；

第4次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手。

##### 背诵：

四次挥手：由客户端首先发起的，第一次挥手客户端会发送一个报文，在报文里面FIN标志位置1，当服务端收到这个报文就知道了客户端想要和我断开连接，但是此时服务端不一定能做好准备，因为当客户端发起断开连接的请求后，对于服务端而言还极有可能有未发送完的消息，还需继续发送，所以此时对于服务端而言只能进行一个消息确认（第二次挥手），即告诉客户端我知道你要和我断开连接，但是我这边还可能没有做好准备，你需要等我一下，等会儿我会告诉你（第三次挥手），于是，发完这个消息确认包过后，可能稍过片刻，服务端会继续发送一个断开连接的报文（第三次挥手），FIN位置1的报文，表示服务端已经做好断开连接的准备，当这个报文发给客户端的时候，客户端同样要给服务端发送一个消息确认的报文（第四次挥手），经过这四次的相互沟通和连接，我就知道了不管是客户端还是服务端都已经做好了断开连接的准备，于是连接断开了，这是我对四次挥手的理解



OSI与TCP/IP各层的结构与功能,都有哪些协议?

学习计算机⽹络时我们⼀般采⽤折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采⽤⼀种只有五层
协议的体系结构，这样既简洁⼜能将概念阐述清楚。

![1694068283877](D:/Program file/typora/img/1694068283877.png)

##### 计算机网络的层次结构：

应用层、运输层、网络层、数据链路层、物理层
应用层的主要任务是h通过应用进程间的交互来完成特定的网络应用，应用层协议定义的是应用进程间的的通信和交互的规则；
运输层的主要任务是负责向两台主机进程之间的通信提供通用的数据传输服务；
网络层：在计算机网络中进行通信的两个计算机可能会经过很多个数据链路，也可能会经过很多个子网，网络层的任务就是选择合适的网间路由和交换结点；
数据链路层简称为链路层，两台主机间的数据传输，都是在一段一段的链路上传输的，这就需要专门的链路层协议；
物理层的作用是实现相邻节点之间的比特流透明传输，尽可能的屏蔽掉具体传输媒介和物理设备的差异；

#####  AOP你了解吗？

这个我可以说一些自己所了解的，aop是面向切面编程，它主要用于将一些与业务无关，但却对多个对象产生的影响的行为和逻辑，抽取公共模块进行复用，减低耦和，比如我们在开发一个项目时，小程序请求的借口每次都需要用到token令牌，但是在每个接口里都写这些代码过于冗余了，这时候我们就需要用到aop了，
首先 自定义一个注解token
第二是定义aop切面，在切面中，定义切点和通知，切点，也就是方法的拦截规则，我们可以按照注解来拦截，也就是某一个带有自定义注解的方法，将被我拦截下来。
第三就是拦截下来后还需要写一个通知，比如环绕通知、前置通知等
aop还可以用于数据库日志记录、spring实现事务等场景.
对mvc有所了解吗
嗯嗯 mvc通俗点来讲它就像个框架，是我们平常开发中都会用到的，比如说编写代码时的controller层，server层、mapper层，通过使用这种方式编写代码可以提高代码的复用性，mvc的全名可以描述为模型-视图-控制器，模型代表的是提供要展示的数据，视图就是负责进行模型的展示，即我们见到的用户界面，控制器是接受用户请求，委托给模型进行处理，处理完毕后把返回的数据模型返回给视图，由视图负责展示
mvc的执行流程可以描述为前端控制器接受用户请求，然后调用处理器映射器，由处理器映射器找到具体的处理器，生成处理器对象和处理器拦截器，再一起返回给前端控制器，然后前段控制器调用具体的处理器，并在方法上添加@ResponseBody注解，通过httpmerssgeconverter来返回结果并转化为json格式

##### TCP,UDP 协议的区别：

UDP 在传送数据之前不需要先建⽴连接，远地主机在收到 UDP 报⽂后，不需要给出任何确认。虽然
UDP 不提供可靠交付，但在某些情况下 UDP 确是⼀种最有效的⼯作⽅式（⼀般⽤于即时通信），⽐
如： QQ 语⾳、 QQ 视频 、直播等等

TCP 提供⾯向连接的服务。在传送数据之前必须先建⽴连接，数据传送结束后要释放连接。 TCP 不提
供⼴播或多播服务。（TCP的可靠体现在TCP在传递数据之前，会有三次握⼿来建⽴连接，⽽且在数据传递时，有确认、窗⼝、重传、拥塞控制机制，在数据传完后，还会断开连接⽤来节约系统资源），这⼀难以避免增加了许多开销，TCP ⼀般⽤于⽂件传输、发送和接收邮件、远程登录等场景

TCP对于UDP来说更安全，但是占用资源更多，速度更慢，所以UDP一般用来qq视频直播等，TCP用来传输文件、邮件等；

TCP 协议如何保证可靠传输：

TCP建立可靠连接的方式有：序列号/确认应答、校验和、流量控制、拥塞控制、ARQ协议（类似3次握手）、超时重传

1. 应⽤数据被分割成 TCP 认为最适合发送的数据块。

2. TCP 给发送的每⼀个包进⾏编号，接收⽅对数据包进⾏排序，把有序数据传送给应⽤层。

3. 校验和： TCP 将保持它⾸部和数据的检验和。这是⼀个端到端的检验和，⽬的是检测数据在传
    输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报⽂段和不确认收到此报⽂
    段。

4. TCP 的接收端会丢弃重复的数据。

5. 流量控制： TCP 连接的每⼀⽅都有固定⼤⼩的缓冲空间，TCP的接收端只允许发送端发送接收端
    缓冲区能接纳的数据。当接收⽅来不及处理发送⽅的数据，能提示发送⽅降低发送的速率，防⽌
    包丢失。TCP 使⽤的流量控制协议是可变⼤⼩的滑动窗⼝协议。 （TCP 利⽤滑动窗⼝实现流量
    控制）

6. 拥塞控制： 当⽹络拥塞时，减少数据的发送。

7. ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对⽅
    确认。在收到确认后再发下⼀个分组。

8. 超时重传： 超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。在重发的过程中，假如一个包经过多次的重发也没有收到对端的确认包，那么就会认为接收端异常，强制关闭连接。并且通知应用通信异常强行终止。

  

  ##### 在浏览器中输⼊url地址 ->> 显示主⻚的过程(⾯试常客)

  1、浏览器中输入url地址后首先会进行DNS解析，找到真实的IP地址，因为互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以要先进行翻译，实现网址到IP地址的转换；

  查找的过程是一个递归查询的过程，首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地；

  第二就是建立TCP连接，也就是三次握手跟四次挥手；

  然后发出Http请求，HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文；

  服务器接收到Http请求，进行处理后返回页面所属于数据（转换为json格式）；页面收到这个Http响应后，会一个一个的响应出用户请求的页面（也就是载⼊解析到的资源⽂件，渲染⻚⾯），这个页面里面有表格，有图片，有文字，也可能有视频等等 。

  ##### HTTP是不保存状态的协议,如何保存⽤户状态

  HTTP 是⼀种不保存状态，即⽆状态（stateless）协议。也就是说 HTTP 协议⾃身不对请求和响应之间
  的通信状态进⾏保存，Session 机制的存在就是为了解决这个问题，Session 的主要作⽤就是通过服务端记录⽤户的状态。典型的场景是购物⻋，当用户要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作的，因为 HTTP 协议是⽆状态的。所以我们使用session机制，服务端给特定的⽤户创建特定的Session 之后就可以标识这个⽤户并且跟踪这个⽤户了（⼀般情况下，服务器会在⼀定时间内保存这个Session，过了时间限制，就会销毁这个Session）。对于实现 Session 跟踪呢？⼤部分情况下，我们都是通过在
  Cookie 中附加⼀个 Session ID 的⽅式来跟踪。

  ##### Http各版本的区别：

  在HTTP/1.0中默认使⽤短连接。也就是说，浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接（无连接），服务器不跟踪每个客户单，也不记录过去的请求（无状态）。

  缺点：

  1、无法复用连接：HTTP/1.0每次发生请求，都需要重新建立连接，而TCP的连接释放工程很耗时，会使网络的利用率变低

  2、队头阻塞，由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。

  ##### HTTP1.0之后

  HTTP/1.1、HTTP/2.0都使用了长连接，使⽤⻓连接的HTTP协议，会在响应头加⼊这⾏代码Connection:keep-alive

  在使⽤⻓连接的情况下，当⼀个⽹⻚打开完成后，客户端和服务器之间⽤于传输HTTP数据的TCP连接不
  会关闭，客户端再次访问这个服务器时，会继续使⽤这⼀条已经建⽴的连接。Keep-Alive不会永久保持
  连接，它有⼀个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现⻓连接需要客
  户端和服务端都⽀持⻓连接，增加了错误状态码，缓存处理，带宽优化和网络连接的使用

  错误状态响应码 :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源
  与资源的当前状态发⽣冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

  3. 缓存处理 :在HTTP1.0中主要使⽤header⾥的If-Modified-Since,Expires来做为缓存判断的标

    准，HTTP1.1则引⼊了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match,
    If-None-Match等更多可供选择的缓存头来控制缓存策略。
  4. 带宽优化及⽹络连接的使⽤ :HTTP1.0中，存在⼀些浪费带宽的现象，例如客户端只是需要某个

    对象的⼀部分，⽽服务器却将整个对象送过来了，并且不⽀持断点续传功能，HTTP1.1则在请求
    头引⼊了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这
    样就⽅便了开发者⾃由的选择以便于充分利⽤带宽和连接。

  ##### Cookie的作⽤是什么?和Session有什么区别？

  Cookie 和 Session都是⽤来跟踪浏览器⽤户身份的会话⽅式，但是两者的应⽤场景不太⼀样。

  Cookie ⼀般⽤来保存⽤户信息 ⽐如①我们在 Cookie 中保存已经登录过得⽤户信息，下次访问⽹站的
  时候⻚⾯可以⾃动帮你登录的⼀些基本信息给填了；②⼀般的⽹站都会有保持登录也就是说下次你再访
  问⽹站的时候就不需要重新登录了，这是因为⽤户登录的时候我们可以存放了⼀个 Token 在 Cookie
  中，下次登录的时候只需要根据 Token 值来查找⽤户即可(为了安全考虑，重新登录⼀般要将 Token
  重写)；③登录⼀次⽹站后访问⽹站其他⻚⾯不需要重新登录。Session 的主要作⽤就是通过服务端记
  录⽤户的状态。 典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作
  的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定的 Session 之后就可以标识这个⽤户
  并且跟踪这个⽤户了。
  Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。
  Cookie 存储在客户端中，⽽Session存储在服务器上，相对来说 Session 安全性更⾼。如果要在
  Cookie 中存储⼀些敏感信息，不要直接写⼊ Cookie 中，最好能将 Cookie 信息加密然后使⽤到的时
  候再去服务器端解密。

  ##### URI和URL的区别是什么?

  URI的作⽤像身份证号⼀样，URL的作⽤更像家庭住址⼀样。URL是⼀种具体的URI，它不仅唯⼀标识资
  源，⽽且还提供了定位该资源的信息。

  #####  HTTP 和 HTTPS 的区别？

  1. 端⼝ ：HTTP的URL由“http://”起始且默认使⽤端⼝80，⽽HTTPS的URL由“https://”起始且默认

    使⽤端⼝443。
  2. 安全性和资源消耗： HTTP 是超文本传输协议，连接很简单，是无状态的，运⾏在TCP之上，所有传输的内容都是明⽂，而HTTPS协议是由 SSL+HTTP 协议构建，所有传输的内容都经过加密，比Http协议更安全；虽然HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP耗费更多服务器资源。
  3. HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(比如官网一般是http，邮箱是 https 。)





你知道分布式吗：

##### 解释一下什么是CAP？

分布性有3个特性，分别是一致性，可用性，分区容错性，但是只能最多满足两个特性

C：一致性（Consistency），数据在多个副本中保持一致，可以理解成两个用户访问两个系统A和B，当A系统数据有变化时，及时同步给B系统，让两个用户看到的数据是一致的。

A：可用性（Availability），系统对外提供服务必须一直处于可用状态，在任何故障下，客户端都能在合理时间内获得服务端非错误的响应。

P：分区容错性（Partition tolerance），在分布式系统中遇到任何网络分区故障，系统仍然能对外提供服务。网络分区，可以这样理解，在分布式系统中，不同的节点分布在不同的子网络中，有可能子网络中只有一个节点，在所有网络正常的情况下，由于某些原因导致这些子节点之间的网络出现故障，导致整个节点环境被切分成了不同的独立区域，这就是网络分区



##### 什么分布式事务？

分布式事务服务（Distributed Transaction Service，DTS）是一个分布式事务框架，用来保障在大规模分布式环境下事务的最终一致性。

CAP理论告诉我们在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的，所以我们只能在一致性和可用性之间进行权衡。

为了保障系统的可用性，互联网系统大多将强一致性需求转换成最终一致性的需求，并通过系统执行幂等性的保证，保证数据的最终一致性。





##### 什么是RESTful API？你有经验设计和开发RESTful API吗？

**RESTful API（Representational State Transferful API）** 是一种设计风格，用于创建Web服务。它基于一组原则和约定，旨在使Web服务更加简单、轻量级和可扩展。RESTful API的核心思想是使用HTTP协议的不同方法（例如GET、POST、PUT、DELETE）来执行各种操作，同时使用URL来标识资源。每个资源都有一个唯一的URL，并且可以通过HTTP方法对其执行操作。

在项目中我们会使用GET、POST等来接受前端发过来的请求

1. **资源：** 将数据模型化为资源，每个资源都由一个唯一的URL标识。例如，一个博客应用可以有文章资源和评论资源，每个都有自己的URL。
2. **HTTP方法：** 使用HTTP方法来执行操作，例如使用GET来获取资源，使用POST来创建资源，使用PUT来更新资源，使用DELETE来删除资源。
3. **状态无关性：** 每个请求应该包含足够的信息，以便服务器能够理解请求，而无需依赖会话状态。这使得API更容易缓存和扩展。
4. **表现层：** 使用不同的表示形式来表示资源，通常是JSON或XML。客户端可以根据需要选择合适的表示形式。
5. **无状态：** 服务器不会存储客户端的状态信息，每个请求都应该包含足够的信息以便服务器理解请求。



玄武云

##### 使用较多的数据结构

##### 讲arraylist跟Hashmap

##### 讲讲list

Java中的List是一个有序的集合，它允许我们按顺序存储和访问元素。List接口提供了许多方法来操作列表中的元素，包括添加、删除、获取、搜索等。List接口继承自Collection接口，因此List也具有Collection接口的所有特性。

ArrayList是List接口的一个实现类，它是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。

##### ArrayList插入删除一定慢吗，什么情况不慢

讲arraylist的概念

ArrayList的插入和删除操作比LinkedList慢，因为当ArrayList需要插入删除一个元素时，会使得数组中的某些元素需要移动，从而使得插入和删除的操作变得非常耗时。ArrayList在插入和删除操作时，可能需要进行数组扩容操作，从而耗费更多的时间。插入和删除操作时，时间复杂度为O(n)，其中n表示ArrayList中元素的个数。

但是，ArrayList的查找速度很快，能够根据给定的下标直接找出对应位置的元素，时间复杂度为O(1)。

##### 线程池有用吗，用在哪

线程池的概念，以及好处

##### spingtask执行过程

##### 索引

回答索引的好处，失效情况，聚集索引，非聚集索引等





有了解和使用过设计模式吗？ 讲讲几个印象最深刻的？   

  2.代理模式有哪些使用场景，除了Spring AOP。


  3.Linux使用过哪些命令？  

  4.top命令显示的内容，显示的是什么的占有率。  

  5.Linux内存分为哪几块了解吗？  

  6.印象深刻的数据结构有哪些？  

ArrayList和LinkedList、hashset

  7.ArrayList和LinkedList哪个更高效？ 在什么情况下？  

ArrayList和LinkedList都是Java中的List接口的实现类，它们都有各自的优缺点。在大部分情况下，使用ArrayList会好一些，因为ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构。对于随机访问樱游get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。

  8.ArrayList什么时候又会低效？  

ArrayList在添加和删除元素时，如果需要在中间或尾部进行操作，LinkedList的效率要高于ArrayList，因为LinkedList不需要移动数据，而ArrayList需要移动数据。当需要在头部进行操作时，LinkedList的效率要低于ArrayList，因为ArrayList可以通过数组下标直接访问元素，而LinkedList需要从头节点开始遍历链表。

  9.了解索引优化吗？ 什么时候用索引，什么时候不用索引？  

索引的创建原则，使用什么索引，回表危害等

一般来说，当表中的数据量较大时，为经常查询的和经常排序的字段建立索引可以提高查询效率。但是，频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件。where条件里用不到的字段，不创建索引。表记录太少，不需要创建索引。经常增删改的表也不适合创建索引。

  10.索引的开销主要体现在哪？  

维护索引、占用空间、回表查询

1. 占用磁盘空间。添加索引后，.ibd文件（innodb引擎）或者.myi文件（myisam引擎）会变大。
2. 降低写操作的速度。因为索引不是直接存储数据的，所以在插入、更新、删除等操作时，需要先维护索引，这会降低写操作的速度。
3. 降低查询速度。虽然索引可以加速查询，但是在某些情况下，索引会降低查询速度。例如，当查询条件不符合索引列时，MySQL需要全表扫描才能返回结果

  11.对MySQL  B+树的理解？



设计模型，回答一个

spring框架

数据库的视图

线程池满了之后的处理；



了解设计模型吗，说一下

spring框架，如何启动的，启动类的注解是什么

项目的服务人员，它的作用是什么；

redis的性能较慢时，如何处理；

二叉查询、快排；

arraylist和linklist；什么时候arraylist比linklist查询更快

项目的技术栈



​		